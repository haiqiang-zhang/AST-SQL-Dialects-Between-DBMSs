--Query--
COMMENT ON RULE rtest_v1_del ON rtest_v1 IS 'delete rule'
--Result--
[]
+--------------------+
--Query--
COMMENT ON RULE rtest_v1_del ON rtest_v1 IS NULL
--Result--
[]
+--------------------+
--Query--
select * from rtest_v1
--Result--
[(1, 11), (2, 12)]
+--------------------+
--Query--
select * from rtest_v1
--Result--
[(2, 12)]
+--------------------+
--Query--
select * from rtest_v1
--Result--
[(1, 11)]
+--------------------+
--Query--
select * from rtest_v1
--Result--
[(1, 11), (2, 12), (2, 13)]
+--------------------+
--Query--
select * from rtest_v1
--Result--
[(1, 11), (2, 12), (2, 13)]
+--------------------+
--Query--
select * from rtest_v1
--Result--
[(1, 21), (2, 22), (3, 23)]
+--------------------+
--Query--
select * from rtest_v1
--Result--
[(1, 21), (2, 22), (3, 23)]
+--------------------+
--Query--
select * from rtest_v1
--Result--
[(1, 21), (2, 22), (3, 23), (1, None), (2, None), (3, None), (4, None), (5, None)]
+--------------------+
--Query--
select * from rtest_v1 where b isnull
--Result--
[(1, None), (2, None), (3, None), (4, None), (5, None)]
+--------------------+
--Query--
select * from rtest_v1
--Result--
[(1, 21), (2, 22), (3, 23)]
+--------------------+
--Query--
select * from rtest_v1
--Result--
[(1, 21), (3, 23), (2, 42)]
+--------------------+
--Query--
select * from rtest_v1
--Result--
[(1, 21), (3, 23), (2, 99)]
+--------------------+
--Query--
select * from rtest_v1
--Result--
[(2, 99), (1, 88), (3, 88)]
+--------------------+
--Query--
select * from rtest_v1
--Result--
[(1, 31), (2, 32), (3, 33)]
+--------------------+
--Query--
select * from rtest_v1
--Result--
[(1, 21), (2, 22), (3, 23)]
+--------------------+
--Query--
select * from rtest_v1
--Result--
[(1, 21), (2, 22), (3, 23), (1, 31), (2, 32), (3, 33), (4, 34), (5, 35)]
+--------------------+
--Query--
select * from rtest_v1
--Result--
[(1, 21), (2, 22), (3, 23), (11, 31), (12, 32), (13, 33), (14, 34), (15, 35)]
+--------------------+
--Query--
select * from rtest_v1
--Result--
[(1, 21), (2, 22), (3, 23), (21, 31), (22, 32), (23, 33), (24, 34), (25, 35)]
+--------------------+
--Query--
select * from rtest_interface
--Result--
[('orion', 'eth0'), ('orion', 'eth1'), ('notjw', 'eth0'), ('neptun', 'eth0')]
+--------------------+
--Query--
select * from rtest_admin
--Result--
[('jw', 'orion'), ('jw', 'notjw'), ('bm', 'neptun')]
+--------------------+
--Query--
select * from rtest_admin order by pname, sysname
--Result--
[('bm', 'neptun'), ('jwieck', 'notjw'), ('jwieck', 'orion')]
+--------------------+
--Query--
select * from rtest_interface
--Result--
[('orion', 'eth0'), ('orion', 'eth1'), ('notjw', 'eth0'), ('neptun', 'eth0')]
+--------------------+
--Query--
select * from rtest_admin
--Result--
[('bm', 'neptun'), ('jwieck', 'orion'), ('jwieck', 'notjw')]
+--------------------+
--Query--
select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal
--Result--
[('gates               ', True, 'fired     ', 0.0, 80000.0), ('gates               ', True, 'hired     ', 80000.0, 0.0), ('wiecc               ', True, 'hired     ', 5000.0, 0.0), ('wieck               ', True, 'honored   ', 6000.0, 5000.0), ('wieck               ', True, 'honored   ', 7000.0, 6000.0)]
+--------------------+
--Query--
select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal
--Result--
[('gates               ', True, 'fired     ', 0.0, 80000.0), ('gates               ', True, 'hired     ', 80000.0, 0.0), ('maier               ', True, 'hired     ', 5000.0, 0.0), ('mayr                ', True, 'hired     ', 6000.0, 0.0), ('meyer               ', True, 'hired     ', 4000.0, 0.0), ('wiecc               ', True, 'hired     ', 5000.0, 0.0), ('wieck               ', True, 'honored   ', 6000.0, 5000.0), ('wieck               ', True, 'honored   ', 7000.0, 6000.0)]
+--------------------+
--Query--
select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal
--Result--
[('gates               ', True, 'fired     ', 0.0, 80000.0), ('gates               ', True, 'hired     ', 80000.0, 0.0), ('maier               ', True, 'hired     ', 5000.0, 0.0), ('maier               ', True, 'honored   ', 6000.0, 5000.0), ('mayr                ', True, 'hired     ', 6000.0, 0.0), ('mayr                ', True, 'honored   ', 7000.0, 6000.0), ('meyer               ', True, 'hired     ', 4000.0, 0.0), ('meyer               ', True, 'honored   ', 5000.0, 4000.0), ('wiecc               ', True, 'hired     ', 5000.0, 0.0), ('wieck               ', True, 'honored   ', 6000.0, 5000.0), ('wieck               ', True, 'honored   ', 7000.0, 6000.0)]
+--------------------+
--Query--
select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal
--Result--
[('gates               ', True, 'fired     ', 0.0, 80000.0), ('gates               ', True, 'hired     ', 80000.0, 0.0), ('maier               ', True, 'fired     ', 0.0, 6000.0), ('maier               ', True, 'hired     ', 5000.0, 0.0), ('maier               ', True, 'honored   ', 6000.0, 5000.0), ('mayr                ', True, 'fired     ', 0.0, 7000.0), ('mayr                ', True, 'hired     ', 6000.0, 0.0), ('mayr                ', True, 'honored   ', 7000.0, 6000.0), ('meyer               ', True, 'fired     ', 0.0, 5000.0), ('meyer               ', True, 'hired     ', 4000.0, 0.0), ('meyer               ', True, 'honored   ', 5000.0, 4000.0), ('wiecc               ', True, 'hired     ', 5000.0, 0.0), ('wieck               ', True, 'honored   ', 6000.0, 5000.0), ('wieck               ', True, 'honored   ', 7000.0, 6000.0)]
+--------------------+
--Query--
select * from rtest_t4
--Result--
[(1, 'Record should go to rtest_t4'), (2, 'Record should go to rtest_t4'), (20, 'Record should go to rtest_t4 and t6'), (26, 'Record should go to rtest_t4 and t8'), (28, 'Record should go to rtest_t4 and t8'), (30, 'Record should go to rtest_t4'), (40, 'Record should go to rtest_t4')]
+--------------------+
--Query--
select * from rtest_t5
--Result--
[(10, 'Record should go to rtest_t5'), (15, 'Record should go to rtest_t5'), (19, 'Record should go to rtest_t5 and t7')]
+--------------------+
--Query--
select * from rtest_t6
--Result--
[(20, 'Record should go to rtest_t4 and t6')]
+--------------------+
--Query--
select * from rtest_t7
--Result--
[(19, 'Record should go to rtest_t5 and t7')]
+--------------------+
--Query--
select * from rtest_t8
--Result--
[(26, 'Record should go to rtest_t4 and t8'), (28, 'Record should go to rtest_t4 and t8')]
+--------------------+
--Query--
select * from rtest_t4
--Result--
[(1, 'Record should go to rtest_t4'), (2, 'Record should go to rtest_t4')]
+--------------------+
--Query--
select * from rtest_t5
--Result--
[(10, 'Record should go to rtest_t5'), (15, 'Record should go to rtest_t5'), (19, 'Record should go to rtest_t5 and t7')]
+--------------------+
--Query--
select * from rtest_t6
--Result--
[]
+--------------------+
--Query--
select * from rtest_t7
--Result--
[(19, 'Record should go to rtest_t5 and t7')]
+--------------------+
--Query--
select * from rtest_t8
--Result--
[]
+--------------------+
--Query--
select * from rtest_t4
--Result--
[(1, 'Record should go to rtest_t4'), (2, 'Record should go to rtest_t4'), (26, 'Record should go to rtest_t4 and t8'), (28, 'Record should go to rtest_t4 and t8')]
+--------------------+
--Query--
select * from rtest_t5
--Result--
[(10, 'Record should go to rtest_t5'), (15, 'Record should go to rtest_t5'), (19, 'Record should go to rtest_t5 and t7')]
+--------------------+
--Query--
select * from rtest_t6
--Result--
[]
+--------------------+
--Query--
select * from rtest_t7
--Result--
[(19, 'Record should go to rtest_t5 and t7')]
+--------------------+
--Query--
select * from rtest_t8
--Result--
[(26, 'Record should go to rtest_t4 and t8'), (28, 'Record should go to rtest_t4 and t8')]
+--------------------+
--Query--
select * from rtest_t4
--Result--
[(1, 'Record should go to rtest_t4'), (2, 'Record should go to rtest_t4'), (26, 'Record should go to rtest_t4 and t8'), (28, 'Record should go to rtest_t4 and t8'), (21, 'Record should go to rtest_t4 and t6'), (31, 'Record should go to rtest_t4'), (41, 'Record should go to rtest_t4')]
+--------------------+
--Query--
select * from rtest_t5
--Result--
[(10, 'Record should go to rtest_t5'), (15, 'Record should go to rtest_t5'), (19, 'Record should go to rtest_t5 and t7')]
+--------------------+
--Query--
select * from rtest_t6
--Result--
[(21, 'Record should go to rtest_t4 and t6')]
+--------------------+
--Query--
select * from rtest_t7
--Result--
[(19, 'Record should go to rtest_t5 and t7')]
+--------------------+
--Query--
select * from rtest_t8
--Result--
[(26, 'Record should go to rtest_t4 and t8'), (28, 'Record should go to rtest_t4 and t8')]
+--------------------+
--Query--
select * from rtest_order2
--Result--
[(1, 1, 'rule 1 - this should run 1st'), (1, 2, 'rule 2 - this should run 2nd'), (1, 3, 'rule 3 - this should run 3rd'), (1, 4, 'rule 4 - this should run 4th')]
+--------------------+
--Query--
select * from rtest_nothn1
--Result--
[(1, 'want this'), (2, 'want this'), (20, 'want this'), (29, 'want this'), (40, 'want this'), (50, 'want this'), (60, 'want this')]
+--------------------+
--Query--
select * from rtest_nothn2
--Result--
[]
+--------------------+
--Query--
select * from rtest_nothn3
--Result--
[(100, 'OK'), (200, 'OK')]
+--------------------+
--Query--
select * from rtest_nothn1
--Result--
[(1, 'want this'), (2, 'want this'), (20, 'want this'), (29, 'want this'), (40, 'want this'), (50, 'want this'), (60, 'want this')]
+--------------------+
--Query--
select * from rtest_nothn2
--Result--
[]
+--------------------+
--Query--
select * from rtest_nothn3
--Result--
[(100, 'OK'), (200, 'OK')]
+--------------------+
--Query--
select * from rtest_vview1
--Result--
[(2, 'item 2'), (4, 'item 4'), (5, 'item 5'), (7, 'item 7')]
+--------------------+
--Query--
select * from rtest_vview2
--Result--
[(1, 'item 1'), (2, 'item 2'), (3, 'item 3'), (5, 'item 5'), (7, 'item 7'), (8, 'item 8')]
+--------------------+
--Query--
select * from rtest_vview3
--Result--
[(2, 'item 2'), (5, 'item 5'), (7, 'item 7')]
+--------------------+
--Query--
select * from rtest_vview4 order by a, b
--Result--
[(2, 'item 2', 2), (4, 'item 4', 1), (5, 'item 5', 1), (7, 'item 7', 4)]
+--------------------+
--Query--
select * from rtest_vview5
--Result--
[(1, 'item 1', 0), (2, 'item 2', 2), (3, 'item 3', 0), (4, 'item 4', 1), (5, 'item 5', 1), (6, 'item 6', 0), (7, 'item 7', 4), (8, 'item 8', 0)]
+--------------------+
--Query--
select * from rtest_view3
--Result--
[(2, 'item 2'), (4, 'item 4'), (5, 'item 5')]
+--------------------+
--Query--
select * from rtest_view3
--Result--
[(1, 'item 1'), (3, 'item 3'), (7, 'item 7'), (8, 'item 8')]
+--------------------+
--Query--
select * from rtest_view3
--Result--
[(2, 'item 2'), (5, 'item 5'), (7, 'item 7')]
+--------------------+
--Query--
select * from rtest_view4 order by a, b
--Result--
[(2, 'item 2', 2), (4, 'item 4', 1), (5, 'item 5', 1)]
+--------------------+
--Query--
select * from rtest_view4
--Result--
[(3, 'item 3', 0), (6, 'item 6', 0), (8, 'item 8', 0)]
+--------------------+
--Query--
select * from rtest_vcomp order by part
--Result--
[('p1', 500.0), ('p2', 300.0), ('p3', 5.0), ('p4', 15.0), ('p5', 17.78), ('p6', 11.176000000000002)]
+--------------------+
--Query--
select * from rtest_vcomp where size_in_cm > 10.0 order by size_in_cm using >
--Result--
[('p1', 500.0), ('p2', 300.0), ('p5', 17.78), ('p4', 15.0), ('p6', 11.176000000000002)]
+--------------------+
--Query--
SELECT * FROM shoelace ORDER BY sl_name
--Result--
[('sl1       ', 5, 'black     ', 80.0, 'cm      ', 80.0), ('sl2       ', 6, 'black     ', 100.0, 'cm      ', 100.0), ('sl3       ', 0, 'black     ', 35.0, 'inch    ', 88.9), ('sl4       ', 8, 'black     ', 40.0, 'inch    ', 101.6), ('sl5       ', 4, 'brown     ', 1.0, 'm       ', 100.0), ('sl6       ', 0, 'brown     ', 0.9, 'm       ', 90.0), ('sl7       ', 7, 'brown     ', 60.0, 'cm      ', 60.0), ('sl8       ', 1, 'brown     ', 40.0, 'inch    ', 101.6)]
+--------------------+
--Query--
SELECT * FROM shoe_ready WHERE total_avail >= 2 ORDER BY 1
--Result--
[('sh1       ', 2, 'sl1       ', 5, 2), ('sh3       ', 4, 'sl7       ', 7, 4)]
+--------------------+
--Query--
SELECT * FROM shoelace_log
--Result--
[('sl7       ', 6, 'Al Bundy', datetime.datetime(1970, 1, 1, 0, 0))]
+--------------------+
--Query--
SELECT * FROM shoelace ORDER BY sl_name
--Result--
[('sl1       ', 5, 'black     ', 80.0, 'cm      ', 80.0), ('sl2       ', 6, 'black     ', 100.0, 'cm      ', 100.0), ('sl3       ', 0, 'black     ', 35.0, 'inch    ', 88.9), ('sl4       ', 8, 'black     ', 40.0, 'inch    ', 101.6), ('sl5       ', 4, 'brown     ', 1.0, 'm       ', 100.0), ('sl6       ', 0, 'brown     ', 0.9, 'm       ', 90.0), ('sl7       ', 6, 'brown     ', 60.0, 'cm      ', 60.0), ('sl8       ', 1, 'brown     ', 40.0, 'inch    ', 101.6)]
+--------------------+
--Query--
SELECT * FROM shoelace ORDER BY sl_name
--Result--
[('sl1       ', 5, 'black     ', 80.0, 'cm      ', 80.0), ('sl2       ', 6, 'black     ', 100.0, 'cm      ', 100.0), ('sl3       ', 10, 'black     ', 35.0, 'inch    ', 88.9), ('sl4       ', 8, 'black     ', 40.0, 'inch    ', 101.6), ('sl5       ', 4, 'brown     ', 1.0, 'm       ', 100.0), ('sl6       ', 20, 'brown     ', 0.9, 'm       ', 90.0), ('sl7       ', 6, 'brown     ', 60.0, 'cm      ', 60.0), ('sl8       ', 21, 'brown     ', 40.0, 'inch    ', 101.6)]
+--------------------+
--Query--
SELECT * FROM shoelace_log ORDER BY sl_name
--Result--
[('sl3       ', 10, 'Al Bundy', datetime.datetime(1970, 1, 1, 0, 0)), ('sl6       ', 20, 'Al Bundy', datetime.datetime(1970, 1, 1, 0, 0)), ('sl7       ', 6, 'Al Bundy', datetime.datetime(1970, 1, 1, 0, 0)), ('sl8       ', 21, 'Al Bundy', datetime.datetime(1970, 1, 1, 0, 0))]
+--------------------+
--Query--
SELECT * FROM shoelace_obsolete ORDER BY sl_len_cm
--Result--
[('sl9       ', 0, 'pink      ', 35.0, 'inch    ', 88.9), ('sl10      ', 1000, 'magenta   ', 40.0, 'inch    ', 101.6)]
+--------------------+
--Query--
SELECT * FROM shoelace_candelete
--Result--
[('sl9       ', 0, 'pink      ', 35.0, 'inch    ', 88.9)]
+--------------------+
--Query--
SELECT * FROM shoelace ORDER BY sl_name
--Result--
[('sl1       ', 5, 'black     ', 80.0, 'cm      ', 80.0), ('sl10      ', 1000, 'magenta   ', 40.0, 'inch    ', 101.6), ('sl2       ', 6, 'black     ', 100.0, 'cm      ', 100.0), ('sl3       ', 10, 'black     ', 35.0, 'inch    ', 88.9), ('sl4       ', 8, 'black     ', 40.0, 'inch    ', 101.6), ('sl5       ', 4, 'brown     ', 1.0, 'm       ', 100.0), ('sl6       ', 20, 'brown     ', 0.9, 'm       ', 90.0), ('sl7       ', 6, 'brown     ', 60.0, 'cm      ', 60.0), ('sl8       ', 21, 'brown     ', 40.0, 'inch    ', 101.6)]
+--------------------+
--Query--
SELECT * FROM shoe ORDER BY shoename
--Result--
[('sh1       ', 2, 'black     ', 70.0, 70.0, 90.0, 90.0, 'cm      '), ('sh2       ', 0, 'black     ', 30.0, 76.2, 40.0, 101.6, 'inch    '), ('sh3       ', 4, 'brown     ', 50.0, 50.0, 65.0, 65.0, 'cm      '), ('sh4       ', 3, 'brown     ', 40.0, 101.6, 50.0, 127.0, 'inch    ')]
+--------------------+
--Query--
SELECT count(*) FROM shoe
--Result--
[(4,)]
+--------------------+
--Query--
select * from rules_foo
--Result--
[(1001,)]
+--------------------+
--Query--
select * from rules_foo
--Result--
[(1001,), (100,)]
+--------------------+
--Query--
select * from rules_foo2
--Result--
[(2,)]
+--------------------+
--Query--
select * from vview
--Result--
[(1, 'parent1', 'descrip1'), (2, 'parent2', None)]
+--------------------+
--Query--
select * from vview
--Result--
[(1, 'parent1', 'descrip1'), (2, 'parent2', None)]
+--------------------+
--Query--
select * from vview
--Result--
[(1, 'parent1', 'descrip1'), (2, 'parent2', None)]
+--------------------+
--Query--
select * from vview
--Result--
[(1, 'parent1', 'descrip1'), (2, 'parent2', None)]
+--------------------+
--Query--
select * from cchild
--Result--
[(1, 'descrip1')]
+--------------------+
--Query--
SELECT viewname, definition FROM pg_views WHERE schemaname = 'pg_catalog' ORDER BY viewname
--Result--
[('pg_available_extension_versions', ' SELECT e.name,\n    e.version,\n    (x.extname IS NOT NULL) AS installed,\n    e.superuser,\n    e.trusted,\n    e.relocatable,\n    e.schema,\n    e.requires,\n    e.comment\n   FROM (pg_available_extension_versions() e(name, version, superuser, trusted, relocatable, schema, requires, comment)\n     LEFT JOIN pg_extension x ON (((e.name = x.extname) AND (e.version = x.extversion))));'), ('pg_available_extensions', ' SELECT e.name,\n    e.default_version,\n    x.extversion AS installed_version,\n    e.comment\n   FROM (pg_available_extensions() e(name, default_version, comment)\n     LEFT JOIN pg_extension x ON ((e.name = x.extname)));'), ('pg_backend_memory_contexts', ' SELECT name,\n    ident,\n    parent,\n    level,\n    total_bytes,\n    total_nblocks,\n    free_bytes,\n    free_chunks,\n    used_bytes\n   FROM pg_get_backend_memory_contexts() pg_get_backend_memory_contexts(name, ident, parent, level, total_bytes, total_nblocks, free_bytes, free_chunks, used_bytes);'), ('pg_config', ' SELECT name,\n    setting\n   FROM pg_config() pg_config(name, setting);'), ('pg_cursors', ' SELECT name,\n    statement,\n    is_holdable,\n    is_binary,\n    is_scrollable,\n    creation_time\n   FROM pg_cursor() c(name, statement, is_holdable, is_binary, is_scrollable, creation_time);'), ('pg_file_settings', ' SELECT sourcefile,\n    sourceline,\n    seqno,\n    name,\n    setting,\n    applied,\n    error\n   FROM pg_show_all_file_settings() a(sourcefile, sourceline, seqno, name, setting, applied, error);'), ('pg_group', ' SELECT rolname AS groname,\n    oid AS grosysid,\n    ARRAY( SELECT pg_auth_members.member\n           FROM pg_auth_members\n          WHERE (pg_auth_members.roleid = pg_authid.oid)) AS grolist\n   FROM pg_authid\n  WHERE (NOT rolcanlogin);'), ('pg_hba_file_rules', ' SELECT rule_number,\n    file_name,\n    line_number,\n    type,\n    database,\n    user_name,\n    address,\n    netmask,\n    auth_method,\n    options,\n    error\n   FROM pg_hba_file_rules() a(rule_number, file_name, line_number, type, database, user_name, address, netmask, auth_method, options, error);'), ('pg_ident_file_mappings', ' SELECT map_number,\n    file_name,\n    line_number,\n    map_name,\n    sys_name,\n    pg_username,\n    error\n   FROM pg_ident_file_mappings() a(map_number, file_name, line_number, map_name, sys_name, pg_username, error);'), ('pg_indexes', ' SELECT n.nspname AS schemaname,\n    c.relname AS tablename,\n    i.relname AS indexname,\n    t.spcname AS tablespace,\n    pg_get_indexdef(i.oid) AS indexdef\n   FROM ((((pg_index x\n     JOIN pg_class c ON ((c.oid = x.indrelid)))\n     JOIN pg_class i ON ((i.oid = x.indexrelid)))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n     LEFT JOIN pg_tablespace t ON ((t.oid = i.reltablespace)))\n  WHERE ((c.relkind = ANY (ARRAY[\'r\'::"char", \'m\'::"char", \'p\'::"char"])) AND (i.relkind = ANY (ARRAY[\'i\'::"char", \'I\'::"char"])));'), ('pg_locks', ' SELECT locktype,\n    database,\n    relation,\n    page,\n    tuple,\n    virtualxid,\n    transactionid,\n    classid,\n    objid,\n    objsubid,\n    virtualtransaction,\n    pid,\n    mode,\n    granted,\n    fastpath,\n    waitstart\n   FROM pg_lock_status() l(locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid, objsubid, virtualtransaction, pid, mode, granted, fastpath, waitstart);'), ('pg_matviews', ' SELECT n.nspname AS schemaname,\n    c.relname AS matviewname,\n    pg_get_userbyid(c.relowner) AS matviewowner,\n    t.spcname AS tablespace,\n    c.relhasindex AS hasindexes,\n    c.relispopulated AS ispopulated,\n    pg_get_viewdef(c.oid) AS definition\n   FROM ((pg_class c\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n     LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace)))\n  WHERE (c.relkind = \'m\'::"char");'), ('pg_policies', ' SELECT n.nspname AS schemaname,\n    c.relname AS tablename,\n    pol.polname AS policyname,\n        CASE\n            WHEN pol.polpermissive THEN \'PERMISSIVE\'::text\n            ELSE \'RESTRICTIVE\'::text\n        END AS permissive,\n        CASE\n            WHEN (pol.polroles = \'{0}\'::oid[]) THEN (string_to_array(\'public\'::text, \'\'::text))::name[]\n            ELSE ARRAY( SELECT pg_authid.rolname\n               FROM pg_authid\n              WHERE (pg_authid.oid = ANY (pol.polroles))\n              ORDER BY pg_authid.rolname)\n        END AS roles,\n        CASE pol.polcmd\n            WHEN \'r\'::"char" THEN \'SELECT\'::text\n            WHEN \'a\'::"char" THEN \'INSERT\'::text\n            WHEN \'w\'::"char" THEN \'UPDATE\'::text\n            WHEN \'d\'::"char" THEN \'DELETE\'::text\n            WHEN \'*\'::"char" THEN \'ALL\'::text\n            ELSE NULL::text\n        END AS cmd,\n    pg_get_expr(pol.polqual, pol.polrelid) AS qual,\n    pg_get_expr(pol.polwithcheck, pol.polrelid) AS with_check\n   FROM ((pg_policy pol\n     JOIN pg_class c ON ((c.oid = pol.polrelid)))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)));'), ('pg_prepared_statements', ' SELECT name,\n    statement,\n    prepare_time,\n    parameter_types,\n    result_types,\n    from_sql,\n    generic_plans,\n    custom_plans\n   FROM pg_prepared_statement() p(name, statement, prepare_time, parameter_types, result_types, from_sql, generic_plans, custom_plans);'), ('pg_prepared_xacts', ' SELECT p.transaction,\n    p.gid,\n    p.prepared,\n    u.rolname AS owner,\n    d.datname AS database\n   FROM ((pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid)\n     LEFT JOIN pg_authid u ON ((p.ownerid = u.oid)))\n     LEFT JOIN pg_database d ON ((p.dbid = d.oid)));'), ('pg_publication_tables', ' SELECT p.pubname,\n    n.nspname AS schemaname,\n    c.relname AS tablename,\n    ( SELECT array_agg(a.attname ORDER BY a.attnum) AS array_agg\n           FROM pg_attribute a\n          WHERE ((a.attrelid = gpt.relid) AND (a.attnum = ANY ((gpt.attrs)::smallint[])))) AS attnames,\n    pg_get_expr(gpt.qual, gpt.relid) AS rowfilter\n   FROM pg_publication p,\n    LATERAL pg_get_publication_tables(VARIADIC ARRAY[(p.pubname)::text]) gpt(pubid, relid, attrs, qual),\n    (pg_class c\n     JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE (c.oid = gpt.relid);'), ('pg_replication_origin_status', ' SELECT local_id,\n    external_id,\n    remote_lsn,\n    local_lsn\n   FROM pg_show_replication_origin_status() pg_show_replication_origin_status(local_id, external_id, remote_lsn, local_lsn);'), ('pg_replication_slots', ' SELECT l.slot_name,\n    l.plugin,\n    l.slot_type,\n    l.datoid,\n    d.datname AS database,\n    l.temporary,\n    l.active,\n    l.active_pid,\n    l.xmin,\n    l.catalog_xmin,\n    l.restart_lsn,\n    l.confirmed_flush_lsn,\n    l.wal_status,\n    l.safe_wal_size,\n    l.two_phase,\n    l.conflicting\n   FROM (pg_get_replication_slots() l(slot_name, plugin, slot_type, datoid, temporary, active, active_pid, xmin, catalog_xmin, restart_lsn, confirmed_flush_lsn, wal_status, safe_wal_size, two_phase, conflicting)\n     LEFT JOIN pg_database d ON ((l.datoid = d.oid)));'), ('pg_roles', " SELECT pg_authid.rolname,\n    pg_authid.rolsuper,\n    pg_authid.rolinherit,\n    pg_authid.rolcreaterole,\n    pg_authid.rolcreatedb,\n    pg_authid.rolcanlogin,\n    pg_authid.rolreplication,\n    pg_authid.rolconnlimit,\n    '********'::text AS rolpassword,\n    pg_authid.rolvaliduntil,\n    pg_authid.rolbypassrls,\n    s.setconfig AS rolconfig,\n    pg_authid.oid\n   FROM (pg_authid\n     LEFT JOIN pg_db_role_setting s ON (((pg_authid.oid = s.setrole) AND (s.setdatabase = (0)::oid))));"), ('pg_rules', " SELECT n.nspname AS schemaname,\n    c.relname AS tablename,\n    r.rulename,\n    pg_get_ruledef(r.oid) AS definition\n   FROM ((pg_rewrite r\n     JOIN pg_class c ON ((c.oid = r.ev_class)))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE (r.rulename <> '_RETURN'::name);"), ('pg_seclabels', ' SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n        CASE\n            WHEN (rel.relkind = ANY (ARRAY[\'r\'::"char", \'p\'::"char"])) THEN \'table\'::text\n            WHEN (rel.relkind = \'v\'::"char") THEN \'view\'::text\n            WHEN (rel.relkind = \'m\'::"char") THEN \'materialized view\'::text\n            WHEN (rel.relkind = \'S\'::"char") THEN \'sequence\'::text\n            WHEN (rel.relkind = \'f\'::"char") THEN \'foreign table\'::text\n            ELSE NULL::text\n        END AS objtype,\n    rel.relnamespace AS objnamespace,\n        CASE\n            WHEN pg_table_is_visible(rel.oid) THEN quote_ident((rel.relname)::text)\n            ELSE ((quote_ident((nsp.nspname)::text) || \'.\'::text) || quote_ident((rel.relname)::text))\n        END AS objname,\n    l.provider,\n    l.label\n   FROM ((pg_seclabel l\n     JOIN pg_class rel ON (((l.classoid = rel.tableoid) AND (l.objoid = rel.oid))))\n     JOIN pg_namespace nsp ON ((rel.relnamespace = nsp.oid)))\n  WHERE (l.objsubid = 0)\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n    \'column\'::text AS objtype,\n    rel.relnamespace AS objnamespace,\n    ((\n        CASE\n            WHEN pg_table_is_visible(rel.oid) THEN quote_ident((rel.relname)::text)\n            ELSE ((quote_ident((nsp.nspname)::text) || \'.\'::text) || quote_ident((rel.relname)::text))\n        END || \'.\'::text) || (att.attname)::text) AS objname,\n    l.provider,\n    l.label\n   FROM (((pg_seclabel l\n     JOIN pg_class rel ON (((l.classoid = rel.tableoid) AND (l.objoid = rel.oid))))\n     JOIN pg_attribute att ON (((rel.oid = att.attrelid) AND (l.objsubid = att.attnum))))\n     JOIN pg_namespace nsp ON ((rel.relnamespace = nsp.oid)))\n  WHERE (l.objsubid <> 0)\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n        CASE pro.prokind\n            WHEN \'a\'::"char" THEN \'aggregate\'::text\n            WHEN \'f\'::"char" THEN \'function\'::text\n            WHEN \'p\'::"char" THEN \'procedure\'::text\n            WHEN \'w\'::"char" THEN \'window\'::text\n            ELSE NULL::text\n        END AS objtype,\n    pro.pronamespace AS objnamespace,\n    (((\n        CASE\n            WHEN pg_function_is_visible(pro.oid) THEN quote_ident((pro.proname)::text)\n            ELSE ((quote_ident((nsp.nspname)::text) || \'.\'::text) || quote_ident((pro.proname)::text))\n        END || \'(\'::text) || pg_get_function_arguments(pro.oid)) || \')\'::text) AS objname,\n    l.provider,\n    l.label\n   FROM ((pg_seclabel l\n     JOIN pg_proc pro ON (((l.classoid = pro.tableoid) AND (l.objoid = pro.oid))))\n     JOIN pg_namespace nsp ON ((pro.pronamespace = nsp.oid)))\n  WHERE (l.objsubid = 0)\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n        CASE\n            WHEN (typ.typtype = \'d\'::"char") THEN \'domain\'::text\n            ELSE \'type\'::text\n        END AS objtype,\n    typ.typnamespace AS objnamespace,\n        CASE\n            WHEN pg_type_is_visible(typ.oid) THEN quote_ident((typ.typname)::text)\n            ELSE ((quote_ident((nsp.nspname)::text) || \'.\'::text) || quote_ident((typ.typname)::text))\n        END AS objname,\n    l.provider,\n    l.label\n   FROM ((pg_seclabel l\n     JOIN pg_type typ ON (((l.classoid = typ.tableoid) AND (l.objoid = typ.oid))))\n     JOIN pg_namespace nsp ON ((typ.typnamespace = nsp.oid)))\n  WHERE (l.objsubid = 0)\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n    \'large object\'::text AS objtype,\n    NULL::oid AS objnamespace,\n    (l.objoid)::text AS objname,\n    l.provider,\n    l.label\n   FROM (pg_seclabel l\n     JOIN pg_largeobject_metadata lom ON ((l.objoid = lom.oid)))\n  WHERE ((l.classoid = (\'pg_largeobject\'::regclass)::oid) AND (l.objsubid = 0))\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n    \'language\'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident((lan.lanname)::text) AS objname,\n    l.provider,\n    l.label\n   FROM (pg_seclabel l\n     JOIN pg_language lan ON (((l.classoid = lan.tableoid) AND (l.objoid = lan.oid))))\n  WHERE (l.objsubid = 0)\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n    \'schema\'::text AS objtype,\n    nsp.oid AS objnamespace,\n    quote_ident((nsp.nspname)::text) AS objname,\n    l.provider,\n    l.label\n   FROM (pg_seclabel l\n     JOIN pg_namespace nsp ON (((l.classoid = nsp.tableoid) AND (l.objoid = nsp.oid))))\n  WHERE (l.objsubid = 0)\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n    \'event trigger\'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident((evt.evtname)::text) AS objname,\n    l.provider,\n    l.label\n   FROM (pg_seclabel l\n     JOIN pg_event_trigger evt ON (((l.classoid = evt.tableoid) AND (l.objoid = evt.oid))))\n  WHERE (l.objsubid = 0)\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n    \'publication\'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident((p.pubname)::text) AS objname,\n    l.provider,\n    l.label\n   FROM (pg_seclabel l\n     JOIN pg_publication p ON (((l.classoid = p.tableoid) AND (l.objoid = p.oid))))\n  WHERE (l.objsubid = 0)\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    0 AS objsubid,\n    \'subscription\'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident((s.subname)::text) AS objname,\n    l.provider,\n    l.label\n   FROM (pg_shseclabel l\n     JOIN pg_subscription s ON (((l.classoid = s.tableoid) AND (l.objoid = s.oid))))\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    0 AS objsubid,\n    \'database\'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident((dat.datname)::text) AS objname,\n    l.provider,\n    l.label\n   FROM (pg_shseclabel l\n     JOIN pg_database dat ON (((l.classoid = dat.tableoid) AND (l.objoid = dat.oid))))\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    0 AS objsubid,\n    \'tablespace\'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident((spc.spcname)::text) AS objname,\n    l.provider,\n    l.label\n   FROM (pg_shseclabel l\n     JOIN pg_tablespace spc ON (((l.classoid = spc.tableoid) AND (l.objoid = spc.oid))))\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    0 AS objsubid,\n    \'role\'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident((rol.rolname)::text) AS objname,\n    l.provider,\n    l.label\n   FROM (pg_shseclabel l\n     JOIN pg_authid rol ON (((l.classoid = rol.tableoid) AND (l.objoid = rol.oid))));'), ('pg_sequences', ' SELECT n.nspname AS schemaname,\n    c.relname AS sequencename,\n    pg_get_userbyid(c.relowner) AS sequenceowner,\n    (s.seqtypid)::regtype AS data_type,\n    s.seqstart AS start_value,\n    s.seqmin AS min_value,\n    s.seqmax AS max_value,\n    s.seqincrement AS increment_by,\n    s.seqcycle AS cycle,\n    s.seqcache AS cache_size,\n        CASE\n            WHEN has_sequence_privilege(c.oid, \'SELECT,USAGE\'::text) THEN pg_sequence_last_value((c.oid)::regclass)\n            ELSE NULL::bigint\n        END AS last_value\n   FROM ((pg_sequence s\n     JOIN pg_class c ON ((c.oid = s.seqrelid)))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE ((NOT pg_is_other_temp_schema(n.oid)) AND (c.relkind = \'S\'::"char"));'), ('pg_settings', ' SELECT name,\n    setting,\n    unit,\n    category,\n    short_desc,\n    extra_desc,\n    context,\n    vartype,\n    source,\n    min_val,\n    max_val,\n    enumvals,\n    boot_val,\n    reset_val,\n    sourcefile,\n    sourceline,\n    pending_restart\n   FROM pg_show_all_settings() a(name, setting, unit, category, short_desc, extra_desc, context, vartype, source, min_val, max_val, enumvals, boot_val, reset_val, sourcefile, sourceline, pending_restart);'), ('pg_shadow', ' SELECT pg_authid.rolname AS usename,\n    pg_authid.oid AS usesysid,\n    pg_authid.rolcreatedb AS usecreatedb,\n    pg_authid.rolsuper AS usesuper,\n    pg_authid.rolreplication AS userepl,\n    pg_authid.rolbypassrls AS usebypassrls,\n    pg_authid.rolpassword AS passwd,\n    pg_authid.rolvaliduntil AS valuntil,\n    s.setconfig AS useconfig\n   FROM (pg_authid\n     LEFT JOIN pg_db_role_setting s ON (((pg_authid.oid = s.setrole) AND (s.setdatabase = (0)::oid))))\n  WHERE pg_authid.rolcanlogin;'), ('pg_shmem_allocations', ' SELECT name,\n    off,\n    size,\n    allocated_size\n   FROM pg_get_shmem_allocations() pg_get_shmem_allocations(name, off, size, allocated_size);'), ('pg_stat_activity', ' SELECT s.datid,\n    d.datname,\n    s.pid,\n    s.leader_pid,\n    s.usesysid,\n    u.rolname AS usename,\n    s.application_name,\n    s.client_addr,\n    s.client_hostname,\n    s.client_port,\n    s.backend_start,\n    s.xact_start,\n    s.query_start,\n    s.state_change,\n    s.wait_event_type,\n    s.wait_event,\n    s.state,\n    s.backend_xid,\n    s.backend_xmin,\n    s.query_id,\n    s.query,\n    s.backend_type\n   FROM ((pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type, wait_event, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin, backend_type, ssl, sslversion, sslcipher, sslbits, ssl_client_dn, ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ, gss_enc, gss_delegation, leader_pid, query_id)\n     LEFT JOIN pg_database d ON ((s.datid = d.oid)))\n     LEFT JOIN pg_authid u ON ((s.usesysid = u.oid)));'), ('pg_stat_all_indexes', ' SELECT c.oid AS relid,\n    i.oid AS indexrelid,\n    n.nspname AS schemaname,\n    c.relname,\n    i.relname AS indexrelname,\n    pg_stat_get_numscans(i.oid) AS idx_scan,\n    pg_stat_get_lastscan(i.oid) AS last_idx_scan,\n    pg_stat_get_tuples_returned(i.oid) AS idx_tup_read,\n    pg_stat_get_tuples_fetched(i.oid) AS idx_tup_fetch\n   FROM (((pg_class c\n     JOIN pg_index x ON ((c.oid = x.indrelid)))\n     JOIN pg_class i ON ((i.oid = x.indexrelid)))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE (c.relkind = ANY (ARRAY[\'r\'::"char", \'t\'::"char", \'m\'::"char"]));'), ('pg_stat_all_tables', ' SELECT c.oid AS relid,\n    n.nspname AS schemaname,\n    c.relname,\n    pg_stat_get_numscans(c.oid) AS seq_scan,\n    pg_stat_get_lastscan(c.oid) AS last_seq_scan,\n    pg_stat_get_tuples_returned(c.oid) AS seq_tup_read,\n    (sum(pg_stat_get_numscans(i.indexrelid)))::bigint AS idx_scan,\n    max(pg_stat_get_lastscan(i.indexrelid)) AS last_idx_scan,\n    ((sum(pg_stat_get_tuples_fetched(i.indexrelid)))::bigint + pg_stat_get_tuples_fetched(c.oid)) AS idx_tup_fetch,\n    pg_stat_get_tuples_inserted(c.oid) AS n_tup_ins,\n    pg_stat_get_tuples_updated(c.oid) AS n_tup_upd,\n    pg_stat_get_tuples_deleted(c.oid) AS n_tup_del,\n    pg_stat_get_tuples_hot_updated(c.oid) AS n_tup_hot_upd,\n    pg_stat_get_tuples_newpage_updated(c.oid) AS n_tup_newpage_upd,\n    pg_stat_get_live_tuples(c.oid) AS n_live_tup,\n    pg_stat_get_dead_tuples(c.oid) AS n_dead_tup,\n    pg_stat_get_mod_since_analyze(c.oid) AS n_mod_since_analyze,\n    pg_stat_get_ins_since_vacuum(c.oid) AS n_ins_since_vacuum,\n    pg_stat_get_last_vacuum_time(c.oid) AS last_vacuum,\n    pg_stat_get_last_autovacuum_time(c.oid) AS last_autovacuum,\n    pg_stat_get_last_analyze_time(c.oid) AS last_analyze,\n    pg_stat_get_last_autoanalyze_time(c.oid) AS last_autoanalyze,\n    pg_stat_get_vacuum_count(c.oid) AS vacuum_count,\n    pg_stat_get_autovacuum_count(c.oid) AS autovacuum_count,\n    pg_stat_get_analyze_count(c.oid) AS analyze_count,\n    pg_stat_get_autoanalyze_count(c.oid) AS autoanalyze_count\n   FROM ((pg_class c\n     LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE (c.relkind = ANY (ARRAY[\'r\'::"char", \'t\'::"char", \'m\'::"char", \'p\'::"char"]))\n  GROUP BY c.oid, n.nspname, c.relname;'), ('pg_stat_archiver', ' SELECT archived_count,\n    last_archived_wal,\n    last_archived_time,\n    failed_count,\n    last_failed_wal,\n    last_failed_time,\n    stats_reset\n   FROM pg_stat_get_archiver() s(archived_count, last_archived_wal, last_archived_time, failed_count, last_failed_wal, last_failed_time, stats_reset);'), ('pg_stat_bgwriter', ' SELECT pg_stat_get_bgwriter_timed_checkpoints() AS checkpoints_timed,\n    pg_stat_get_bgwriter_requested_checkpoints() AS checkpoints_req,\n    pg_stat_get_checkpoint_write_time() AS checkpoint_write_time,\n    pg_stat_get_checkpoint_sync_time() AS checkpoint_sync_time,\n    pg_stat_get_bgwriter_buf_written_checkpoints() AS buffers_checkpoint,\n    pg_stat_get_bgwriter_buf_written_clean() AS buffers_clean,\n    pg_stat_get_bgwriter_maxwritten_clean() AS maxwritten_clean,\n    pg_stat_get_buf_written_backend() AS buffers_backend,\n    pg_stat_get_buf_fsync_backend() AS buffers_backend_fsync,\n    pg_stat_get_buf_alloc() AS buffers_alloc,\n    pg_stat_get_bgwriter_stat_reset_time() AS stats_reset;'), ('pg_stat_database', ' SELECT oid AS datid,\n    datname,\n        CASE\n            WHEN (oid = (0)::oid) THEN 0\n            ELSE pg_stat_get_db_numbackends(oid)\n        END AS numbackends,\n    pg_stat_get_db_xact_commit(oid) AS xact_commit,\n    pg_stat_get_db_xact_rollback(oid) AS xact_rollback,\n    (pg_stat_get_db_blocks_fetched(oid) - pg_stat_get_db_blocks_hit(oid)) AS blks_read,\n    pg_stat_get_db_blocks_hit(oid) AS blks_hit,\n    pg_stat_get_db_tuples_returned(oid) AS tup_returned,\n    pg_stat_get_db_tuples_fetched(oid) AS tup_fetched,\n    pg_stat_get_db_tuples_inserted(oid) AS tup_inserted,\n    pg_stat_get_db_tuples_updated(oid) AS tup_updated,\n    pg_stat_get_db_tuples_deleted(oid) AS tup_deleted,\n    pg_stat_get_db_conflict_all(oid) AS conflicts,\n    pg_stat_get_db_temp_files(oid) AS temp_files,\n    pg_stat_get_db_temp_bytes(oid) AS temp_bytes,\n    pg_stat_get_db_deadlocks(oid) AS deadlocks,\n    pg_stat_get_db_checksum_failures(oid) AS checksum_failures,\n    pg_stat_get_db_checksum_last_failure(oid) AS checksum_last_failure,\n    pg_stat_get_db_blk_read_time(oid) AS blk_read_time,\n    pg_stat_get_db_blk_write_time(oid) AS blk_write_time,\n    pg_stat_get_db_session_time(oid) AS session_time,\n    pg_stat_get_db_active_time(oid) AS active_time,\n    pg_stat_get_db_idle_in_transaction_time(oid) AS idle_in_transaction_time,\n    pg_stat_get_db_sessions(oid) AS sessions,\n    pg_stat_get_db_sessions_abandoned(oid) AS sessions_abandoned,\n    pg_stat_get_db_sessions_fatal(oid) AS sessions_fatal,\n    pg_stat_get_db_sessions_killed(oid) AS sessions_killed,\n    pg_stat_get_db_stat_reset_time(oid) AS stats_reset\n   FROM ( SELECT 0 AS oid,\n            NULL::name AS datname\n        UNION ALL\n         SELECT pg_database.oid,\n            pg_database.datname\n           FROM pg_database) d;'), ('pg_stat_database_conflicts', ' SELECT oid AS datid,\n    datname,\n    pg_stat_get_db_conflict_tablespace(oid) AS confl_tablespace,\n    pg_stat_get_db_conflict_lock(oid) AS confl_lock,\n    pg_stat_get_db_conflict_snapshot(oid) AS confl_snapshot,\n    pg_stat_get_db_conflict_bufferpin(oid) AS confl_bufferpin,\n    pg_stat_get_db_conflict_startup_deadlock(oid) AS confl_deadlock,\n    pg_stat_get_db_conflict_logicalslot(oid) AS confl_active_logicalslot\n   FROM pg_database d;'), ('pg_stat_gssapi', ' SELECT pid,\n    gss_auth AS gss_authenticated,\n    gss_princ AS principal,\n    gss_enc AS encrypted,\n    gss_delegation AS credentials_delegated\n   FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type, wait_event, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin, backend_type, ssl, sslversion, sslcipher, sslbits, ssl_client_dn, ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ, gss_enc, gss_delegation, leader_pid, query_id)\n  WHERE (client_port IS NOT NULL);'), ('pg_stat_io', ' SELECT backend_type,\n    object,\n    context,\n    reads,\n    read_time,\n    writes,\n    write_time,\n    writebacks,\n    writeback_time,\n    extends,\n    extend_time,\n    op_bytes,\n    hits,\n    evictions,\n    reuses,\n    fsyncs,\n    fsync_time,\n    stats_reset\n   FROM pg_stat_get_io() b(backend_type, object, context, reads, read_time, writes, write_time, writebacks, writeback_time, extends, extend_time, op_bytes, hits, evictions, reuses, fsyncs, fsync_time, stats_reset);'), ('pg_stat_progress_analyze', " SELECT s.pid,\n    s.datid,\n    d.datname,\n    s.relid,\n        CASE s.param1\n            WHEN 0 THEN 'initializing'::text\n            WHEN 1 THEN 'acquiring sample rows'::text\n            WHEN 2 THEN 'acquiring inherited sample rows'::text\n            WHEN 3 THEN 'computing statistics'::text\n            WHEN 4 THEN 'computing extended statistics'::text\n            WHEN 5 THEN 'finalizing analyze'::text\n            ELSE NULL::text\n        END AS phase,\n    s.param2 AS sample_blks_total,\n    s.param3 AS sample_blks_scanned,\n    s.param4 AS ext_stats_total,\n    s.param5 AS ext_stats_computed,\n    s.param6 AS child_tables_total,\n    s.param7 AS child_tables_done,\n    (s.param8)::oid AS current_child_table_relid\n   FROM (pg_stat_get_progress_info('ANALYZE'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20)\n     LEFT JOIN pg_database d ON ((s.datid = d.oid)));"), ('pg_stat_progress_basebackup', " SELECT pid,\n        CASE param1\n            WHEN 0 THEN 'initializing'::text\n            WHEN 1 THEN 'waiting for checkpoint to finish'::text\n            WHEN 2 THEN 'estimating backup size'::text\n            WHEN 3 THEN 'streaming database files'::text\n            WHEN 4 THEN 'waiting for wal archiving to finish'::text\n            WHEN 5 THEN 'transferring wal files'::text\n            ELSE NULL::text\n        END AS phase,\n        CASE param2\n            WHEN '-1'::integer THEN NULL::bigint\n            ELSE param2\n        END AS backup_total,\n    param3 AS backup_streamed,\n    param4 AS tablespaces_total,\n    param5 AS tablespaces_streamed\n   FROM pg_stat_get_progress_info('BASEBACKUP'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20);"), ('pg_stat_progress_cluster', " SELECT s.pid,\n    s.datid,\n    d.datname,\n    s.relid,\n        CASE s.param1\n            WHEN 1 THEN 'CLUSTER'::text\n            WHEN 2 THEN 'VACUUM FULL'::text\n            ELSE NULL::text\n        END AS command,\n        CASE s.param2\n            WHEN 0 THEN 'initializing'::text\n            WHEN 1 THEN 'seq scanning heap'::text\n            WHEN 2 THEN 'index scanning heap'::text\n            WHEN 3 THEN 'sorting tuples'::text\n            WHEN 4 THEN 'writing new heap'::text\n            WHEN 5 THEN 'swapping relation files'::text\n            WHEN 6 THEN 'rebuilding index'::text\n            WHEN 7 THEN 'performing final cleanup'::text\n            ELSE NULL::text\n        END AS phase,\n    (s.param3)::oid AS cluster_index_relid,\n    s.param4 AS heap_tuples_scanned,\n    s.param5 AS heap_tuples_written,\n    s.param6 AS heap_blks_total,\n    s.param7 AS heap_blks_scanned,\n    s.param8 AS index_rebuild_count\n   FROM (pg_stat_get_progress_info('CLUSTER'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20)\n     LEFT JOIN pg_database d ON ((s.datid = d.oid)));"), ('pg_stat_progress_copy', " SELECT s.pid,\n    s.datid,\n    d.datname,\n    s.relid,\n        CASE s.param5\n            WHEN 1 THEN 'COPY FROM'::text\n            WHEN 2 THEN 'COPY TO'::text\n            ELSE NULL::text\n        END AS command,\n        CASE s.param6\n            WHEN 1 THEN 'FILE'::text\n            WHEN 2 THEN 'PROGRAM'::text\n            WHEN 3 THEN 'PIPE'::text\n            WHEN 4 THEN 'CALLBACK'::text\n            ELSE NULL::text\n        END AS type,\n    s.param1 AS bytes_processed,\n    s.param2 AS bytes_total,\n    s.param3 AS tuples_processed,\n    s.param4 AS tuples_excluded\n   FROM (pg_stat_get_progress_info('COPY'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20)\n     LEFT JOIN pg_database d ON ((s.datid = d.oid)));"), ('pg_stat_progress_create_index', " SELECT s.pid,\n    s.datid,\n    d.datname,\n    s.relid,\n    (s.param7)::oid AS index_relid,\n        CASE s.param1\n            WHEN 1 THEN 'CREATE INDEX'::text\n            WHEN 2 THEN 'CREATE INDEX CONCURRENTLY'::text\n            WHEN 3 THEN 'REINDEX'::text\n            WHEN 4 THEN 'REINDEX CONCURRENTLY'::text\n            ELSE NULL::text\n        END AS command,\n        CASE s.param10\n            WHEN 0 THEN 'initializing'::text\n            WHEN 1 THEN 'waiting for writers before build'::text\n            WHEN 2 THEN ('building index'::text || COALESCE((': '::text || pg_indexam_progress_phasename((s.param9)::oid, s.param11)), ''::text))\n            WHEN 3 THEN 'waiting for writers before validation'::text\n            WHEN 4 THEN 'index validation: scanning index'::text\n            WHEN 5 THEN 'index validation: sorting tuples'::text\n            WHEN 6 THEN 'index validation: scanning table'::text\n            WHEN 7 THEN 'waiting for old snapshots'::text\n            WHEN 8 THEN 'waiting for readers before marking dead'::text\n            WHEN 9 THEN 'waiting for readers before dropping'::text\n            ELSE NULL::text\n        END AS phase,\n    s.param4 AS lockers_total,\n    s.param5 AS lockers_done,\n    s.param6 AS current_locker_pid,\n    s.param16 AS blocks_total,\n    s.param17 AS blocks_done,\n    s.param12 AS tuples_total,\n    s.param13 AS tuples_done,\n    s.param14 AS partitions_total,\n    s.param15 AS partitions_done\n   FROM (pg_stat_get_progress_info('CREATE INDEX'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20)\n     LEFT JOIN pg_database d ON ((s.datid = d.oid)));"), ('pg_stat_progress_vacuum', " SELECT s.pid,\n    s.datid,\n    d.datname,\n    s.relid,\n        CASE s.param1\n            WHEN 0 THEN 'initializing'::text\n            WHEN 1 THEN 'scanning heap'::text\n            WHEN 2 THEN 'vacuuming indexes'::text\n            WHEN 3 THEN 'vacuuming heap'::text\n            WHEN 4 THEN 'cleaning up indexes'::text\n            WHEN 5 THEN 'truncating heap'::text\n            WHEN 6 THEN 'performing final cleanup'::text\n            ELSE NULL::text\n        END AS phase,\n    s.param2 AS heap_blks_total,\n    s.param3 AS heap_blks_scanned,\n    s.param4 AS heap_blks_vacuumed,\n    s.param5 AS index_vacuum_count,\n    s.param6 AS max_dead_tuples,\n    s.param7 AS num_dead_tuples\n   FROM (pg_stat_get_progress_info('VACUUM'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20)\n     LEFT JOIN pg_database d ON ((s.datid = d.oid)));"), ('pg_stat_recovery_prefetch', ' SELECT stats_reset,\n    prefetch,\n    hit,\n    skip_init,\n    skip_new,\n    skip_fpw,\n    skip_rep,\n    wal_distance,\n    block_distance,\n    io_depth\n   FROM pg_stat_get_recovery_prefetch() s(stats_reset, prefetch, hit, skip_init, skip_new, skip_fpw, skip_rep, wal_distance, block_distance, io_depth);'), ('pg_stat_replication', ' SELECT s.pid,\n    s.usesysid,\n    u.rolname AS usename,\n    s.application_name,\n    s.client_addr,\n    s.client_hostname,\n    s.client_port,\n    s.backend_start,\n    s.backend_xmin,\n    w.state,\n    w.sent_lsn,\n    w.write_lsn,\n    w.flush_lsn,\n    w.replay_lsn,\n    w.write_lag,\n    w.flush_lag,\n    w.replay_lag,\n    w.sync_priority,\n    w.sync_state,\n    w.reply_time\n   FROM ((pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type, wait_event, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin, backend_type, ssl, sslversion, sslcipher, sslbits, ssl_client_dn, ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ, gss_enc, gss_delegation, leader_pid, query_id)\n     JOIN pg_stat_get_wal_senders() w(pid, state, sent_lsn, write_lsn, flush_lsn, replay_lsn, write_lag, flush_lag, replay_lag, sync_priority, sync_state, reply_time) ON ((s.pid = w.pid)))\n     LEFT JOIN pg_authid u ON ((s.usesysid = u.oid)));'), ('pg_stat_replication_slots', ' SELECT s.slot_name,\n    s.spill_txns,\n    s.spill_count,\n    s.spill_bytes,\n    s.stream_txns,\n    s.stream_count,\n    s.stream_bytes,\n    s.total_txns,\n    s.total_bytes,\n    s.stats_reset\n   FROM pg_replication_slots r,\n    LATERAL pg_stat_get_replication_slot((r.slot_name)::text) s(slot_name, spill_txns, spill_count, spill_bytes, stream_txns, stream_count, stream_bytes, total_txns, total_bytes, stats_reset)\n  WHERE (r.datoid IS NOT NULL);'), ('pg_stat_slru', ' SELECT name,\n    blks_zeroed,\n    blks_hit,\n    blks_read,\n    blks_written,\n    blks_exists,\n    flushes,\n    truncates,\n    stats_reset\n   FROM pg_stat_get_slru() s(name, blks_zeroed, blks_hit, blks_read, blks_written, blks_exists, flushes, truncates, stats_reset);'), ('pg_stat_ssl', ' SELECT pid,\n    ssl,\n    sslversion AS version,\n    sslcipher AS cipher,\n    sslbits AS bits,\n    ssl_client_dn AS client_dn,\n    ssl_client_serial AS client_serial,\n    ssl_issuer_dn AS issuer_dn\n   FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type, wait_event, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin, backend_type, ssl, sslversion, sslcipher, sslbits, ssl_client_dn, ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ, gss_enc, gss_delegation, leader_pid, query_id)\n  WHERE (client_port IS NOT NULL);'), ('pg_stat_subscription', ' SELECT su.oid AS subid,\n    su.subname,\n    st.pid,\n    st.leader_pid,\n    st.relid,\n    st.received_lsn,\n    st.last_msg_send_time,\n    st.last_msg_receipt_time,\n    st.latest_end_lsn,\n    st.latest_end_time\n   FROM (pg_subscription su\n     LEFT JOIN pg_stat_get_subscription(NULL::oid) st(subid, relid, pid, leader_pid, received_lsn, last_msg_send_time, last_msg_receipt_time, latest_end_lsn, latest_end_time) ON ((st.subid = su.oid)));'), ('pg_stat_subscription_stats', ' SELECT ss.subid,\n    s.subname,\n    ss.apply_error_count,\n    ss.sync_error_count,\n    ss.stats_reset\n   FROM pg_subscription s,\n    LATERAL pg_stat_get_subscription_stats(s.oid) ss(subid, apply_error_count, sync_error_count, stats_reset);'), ('pg_stat_sys_indexes', " SELECT relid,\n    indexrelid,\n    schemaname,\n    relname,\n    indexrelname,\n    idx_scan,\n    last_idx_scan,\n    idx_tup_read,\n    idx_tup_fetch\n   FROM pg_stat_all_indexes\n  WHERE ((schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (schemaname ~ '^pg_toast'::text));"), ('pg_stat_sys_tables', " SELECT relid,\n    schemaname,\n    relname,\n    seq_scan,\n    last_seq_scan,\n    seq_tup_read,\n    idx_scan,\n    last_idx_scan,\n    idx_tup_fetch,\n    n_tup_ins,\n    n_tup_upd,\n    n_tup_del,\n    n_tup_hot_upd,\n    n_tup_newpage_upd,\n    n_live_tup,\n    n_dead_tup,\n    n_mod_since_analyze,\n    n_ins_since_vacuum,\n    last_vacuum,\n    last_autovacuum,\n    last_analyze,\n    last_autoanalyze,\n    vacuum_count,\n    autovacuum_count,\n    analyze_count,\n    autoanalyze_count\n   FROM pg_stat_all_tables\n  WHERE ((schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (schemaname ~ '^pg_toast'::text));"), ('pg_stat_user_functions', ' SELECT p.oid AS funcid,\n    n.nspname AS schemaname,\n    p.proname AS funcname,\n    pg_stat_get_function_calls(p.oid) AS calls,\n    pg_stat_get_function_total_time(p.oid) AS total_time,\n    pg_stat_get_function_self_time(p.oid) AS self_time\n   FROM (pg_proc p\n     LEFT JOIN pg_namespace n ON ((n.oid = p.pronamespace)))\n  WHERE ((p.prolang <> (12)::oid) AND (pg_stat_get_function_calls(p.oid) IS NOT NULL));'), ('pg_stat_user_indexes', " SELECT relid,\n    indexrelid,\n    schemaname,\n    relname,\n    indexrelname,\n    idx_scan,\n    last_idx_scan,\n    idx_tup_read,\n    idx_tup_fetch\n   FROM pg_stat_all_indexes\n  WHERE ((schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (schemaname !~ '^pg_toast'::text));"), ('pg_stat_user_tables', " SELECT relid,\n    schemaname,\n    relname,\n    seq_scan,\n    last_seq_scan,\n    seq_tup_read,\n    idx_scan,\n    last_idx_scan,\n    idx_tup_fetch,\n    n_tup_ins,\n    n_tup_upd,\n    n_tup_del,\n    n_tup_hot_upd,\n    n_tup_newpage_upd,\n    n_live_tup,\n    n_dead_tup,\n    n_mod_since_analyze,\n    n_ins_since_vacuum,\n    last_vacuum,\n    last_autovacuum,\n    last_analyze,\n    last_autoanalyze,\n    vacuum_count,\n    autovacuum_count,\n    analyze_count,\n    autoanalyze_count\n   FROM pg_stat_all_tables\n  WHERE ((schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (schemaname !~ '^pg_toast'::text));"), ('pg_stat_wal', ' SELECT wal_records,\n    wal_fpi,\n    wal_bytes,\n    wal_buffers_full,\n    wal_write,\n    wal_sync,\n    wal_write_time,\n    wal_sync_time,\n    stats_reset\n   FROM pg_stat_get_wal() w(wal_records, wal_fpi, wal_bytes, wal_buffers_full, wal_write, wal_sync, wal_write_time, wal_sync_time, stats_reset);'), ('pg_stat_wal_receiver', ' SELECT pid,\n    status,\n    receive_start_lsn,\n    receive_start_tli,\n    written_lsn,\n    flushed_lsn,\n    received_tli,\n    last_msg_send_time,\n    last_msg_receipt_time,\n    latest_end_lsn,\n    latest_end_time,\n    slot_name,\n    sender_host,\n    sender_port,\n    conninfo\n   FROM pg_stat_get_wal_receiver() s(pid, status, receive_start_lsn, receive_start_tli, written_lsn, flushed_lsn, received_tli, last_msg_send_time, last_msg_receipt_time, latest_end_lsn, latest_end_time, slot_name, sender_host, sender_port, conninfo)\n  WHERE (pid IS NOT NULL);'), ('pg_stat_xact_all_tables', ' SELECT c.oid AS relid,\n    n.nspname AS schemaname,\n    c.relname,\n    pg_stat_get_xact_numscans(c.oid) AS seq_scan,\n    pg_stat_get_xact_tuples_returned(c.oid) AS seq_tup_read,\n    (sum(pg_stat_get_xact_numscans(i.indexrelid)))::bigint AS idx_scan,\n    ((sum(pg_stat_get_xact_tuples_fetched(i.indexrelid)))::bigint + pg_stat_get_xact_tuples_fetched(c.oid)) AS idx_tup_fetch,\n    pg_stat_get_xact_tuples_inserted(c.oid) AS n_tup_ins,\n    pg_stat_get_xact_tuples_updated(c.oid) AS n_tup_upd,\n    pg_stat_get_xact_tuples_deleted(c.oid) AS n_tup_del,\n    pg_stat_get_xact_tuples_hot_updated(c.oid) AS n_tup_hot_upd,\n    pg_stat_get_xact_tuples_newpage_updated(c.oid) AS n_tup_newpage_upd\n   FROM ((pg_class c\n     LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE (c.relkind = ANY (ARRAY[\'r\'::"char", \'t\'::"char", \'m\'::"char", \'p\'::"char"]))\n  GROUP BY c.oid, n.nspname, c.relname;'), ('pg_stat_xact_sys_tables', " SELECT relid,\n    schemaname,\n    relname,\n    seq_scan,\n    seq_tup_read,\n    idx_scan,\n    idx_tup_fetch,\n    n_tup_ins,\n    n_tup_upd,\n    n_tup_del,\n    n_tup_hot_upd,\n    n_tup_newpage_upd\n   FROM pg_stat_xact_all_tables\n  WHERE ((schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (schemaname ~ '^pg_toast'::text));"), ('pg_stat_xact_user_functions', ' SELECT p.oid AS funcid,\n    n.nspname AS schemaname,\n    p.proname AS funcname,\n    pg_stat_get_xact_function_calls(p.oid) AS calls,\n    pg_stat_get_xact_function_total_time(p.oid) AS total_time,\n    pg_stat_get_xact_function_self_time(p.oid) AS self_time\n   FROM (pg_proc p\n     LEFT JOIN pg_namespace n ON ((n.oid = p.pronamespace)))\n  WHERE ((p.prolang <> (12)::oid) AND (pg_stat_get_xact_function_calls(p.oid) IS NOT NULL));'), ('pg_stat_xact_user_tables', " SELECT relid,\n    schemaname,\n    relname,\n    seq_scan,\n    seq_tup_read,\n    idx_scan,\n    idx_tup_fetch,\n    n_tup_ins,\n    n_tup_upd,\n    n_tup_del,\n    n_tup_hot_upd,\n    n_tup_newpage_upd\n   FROM pg_stat_xact_all_tables\n  WHERE ((schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (schemaname !~ '^pg_toast'::text));"), ('pg_statio_all_indexes', ' SELECT c.oid AS relid,\n    i.oid AS indexrelid,\n    n.nspname AS schemaname,\n    c.relname,\n    i.relname AS indexrelname,\n    (pg_stat_get_blocks_fetched(i.oid) - pg_stat_get_blocks_hit(i.oid)) AS idx_blks_read,\n    pg_stat_get_blocks_hit(i.oid) AS idx_blks_hit\n   FROM (((pg_class c\n     JOIN pg_index x ON ((c.oid = x.indrelid)))\n     JOIN pg_class i ON ((i.oid = x.indexrelid)))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE (c.relkind = ANY (ARRAY[\'r\'::"char", \'t\'::"char", \'m\'::"char"]));'), ('pg_statio_all_sequences', ' SELECT c.oid AS relid,\n    n.nspname AS schemaname,\n    c.relname,\n    (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS blks_read,\n    pg_stat_get_blocks_hit(c.oid) AS blks_hit\n   FROM (pg_class c\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE (c.relkind = \'S\'::"char");'), ('pg_statio_all_tables', ' SELECT c.oid AS relid,\n    n.nspname AS schemaname,\n    c.relname,\n    (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS heap_blks_read,\n    pg_stat_get_blocks_hit(c.oid) AS heap_blks_hit,\n    i.idx_blks_read,\n    i.idx_blks_hit,\n    (pg_stat_get_blocks_fetched(t.oid) - pg_stat_get_blocks_hit(t.oid)) AS toast_blks_read,\n    pg_stat_get_blocks_hit(t.oid) AS toast_blks_hit,\n    x.idx_blks_read AS tidx_blks_read,\n    x.idx_blks_hit AS tidx_blks_hit\n   FROM ((((pg_class c\n     LEFT JOIN pg_class t ON ((c.reltoastrelid = t.oid)))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n     LEFT JOIN LATERAL ( SELECT (sum((pg_stat_get_blocks_fetched(pg_index.indexrelid) - pg_stat_get_blocks_hit(pg_index.indexrelid))))::bigint AS idx_blks_read,\n            (sum(pg_stat_get_blocks_hit(pg_index.indexrelid)))::bigint AS idx_blks_hit\n           FROM pg_index\n          WHERE (pg_index.indrelid = c.oid)) i ON (true))\n     LEFT JOIN LATERAL ( SELECT (sum((pg_stat_get_blocks_fetched(pg_index.indexrelid) - pg_stat_get_blocks_hit(pg_index.indexrelid))))::bigint AS idx_blks_read,\n            (sum(pg_stat_get_blocks_hit(pg_index.indexrelid)))::bigint AS idx_blks_hit\n           FROM pg_index\n          WHERE (pg_index.indrelid = t.oid)) x ON (true))\n  WHERE (c.relkind = ANY (ARRAY[\'r\'::"char", \'t\'::"char", \'m\'::"char"]));'), ('pg_statio_sys_indexes', " SELECT relid,\n    indexrelid,\n    schemaname,\n    relname,\n    indexrelname,\n    idx_blks_read,\n    idx_blks_hit\n   FROM pg_statio_all_indexes\n  WHERE ((schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (schemaname ~ '^pg_toast'::text));"), ('pg_statio_sys_sequences', " SELECT relid,\n    schemaname,\n    relname,\n    blks_read,\n    blks_hit\n   FROM pg_statio_all_sequences\n  WHERE ((schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (schemaname ~ '^pg_toast'::text));"), ('pg_statio_sys_tables', " SELECT relid,\n    schemaname,\n    relname,\n    heap_blks_read,\n    heap_blks_hit,\n    idx_blks_read,\n    idx_blks_hit,\n    toast_blks_read,\n    toast_blks_hit,\n    tidx_blks_read,\n    tidx_blks_hit\n   FROM pg_statio_all_tables\n  WHERE ((schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (schemaname ~ '^pg_toast'::text));"), ('pg_statio_user_indexes', " SELECT relid,\n    indexrelid,\n    schemaname,\n    relname,\n    indexrelname,\n    idx_blks_read,\n    idx_blks_hit\n   FROM pg_statio_all_indexes\n  WHERE ((schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (schemaname !~ '^pg_toast'::text));"), ('pg_statio_user_sequences', " SELECT relid,\n    schemaname,\n    relname,\n    blks_read,\n    blks_hit\n   FROM pg_statio_all_sequences\n  WHERE ((schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (schemaname !~ '^pg_toast'::text));"), ('pg_statio_user_tables', " SELECT relid,\n    schemaname,\n    relname,\n    heap_blks_read,\n    heap_blks_hit,\n    idx_blks_read,\n    idx_blks_hit,\n    toast_blks_read,\n    toast_blks_hit,\n    tidx_blks_read,\n    tidx_blks_hit\n   FROM pg_statio_all_tables\n  WHERE ((schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (schemaname !~ '^pg_toast'::text));"), ('pg_stats', " SELECT n.nspname AS schemaname,\n    c.relname AS tablename,\n    a.attname,\n    s.stainherit AS inherited,\n    s.stanullfrac AS null_frac,\n    s.stawidth AS avg_width,\n    s.stadistinct AS n_distinct,\n        CASE\n            WHEN (s.stakind1 = 1) THEN s.stavalues1\n            WHEN (s.stakind2 = 1) THEN s.stavalues2\n            WHEN (s.stakind3 = 1) THEN s.stavalues3\n            WHEN (s.stakind4 = 1) THEN s.stavalues4\n            WHEN (s.stakind5 = 1) THEN s.stavalues5\n            ELSE NULL::anyarray\n        END AS most_common_vals,\n        CASE\n            WHEN (s.stakind1 = 1) THEN s.stanumbers1\n            WHEN (s.stakind2 = 1) THEN s.stanumbers2\n            WHEN (s.stakind3 = 1) THEN s.stanumbers3\n            WHEN (s.stakind4 = 1) THEN s.stanumbers4\n            WHEN (s.stakind5 = 1) THEN s.stanumbers5\n            ELSE NULL::real[]\n        END AS most_common_freqs,\n        CASE\n            WHEN (s.stakind1 = 2) THEN s.stavalues1\n            WHEN (s.stakind2 = 2) THEN s.stavalues2\n            WHEN (s.stakind3 = 2) THEN s.stavalues3\n            WHEN (s.stakind4 = 2) THEN s.stavalues4\n            WHEN (s.stakind5 = 2) THEN s.stavalues5\n            ELSE NULL::anyarray\n        END AS histogram_bounds,\n        CASE\n            WHEN (s.stakind1 = 3) THEN s.stanumbers1[1]\n            WHEN (s.stakind2 = 3) THEN s.stanumbers2[1]\n            WHEN (s.stakind3 = 3) THEN s.stanumbers3[1]\n            WHEN (s.stakind4 = 3) THEN s.stanumbers4[1]\n            WHEN (s.stakind5 = 3) THEN s.stanumbers5[1]\n            ELSE NULL::real\n        END AS correlation,\n        CASE\n            WHEN (s.stakind1 = 4) THEN s.stavalues1\n            WHEN (s.stakind2 = 4) THEN s.stavalues2\n            WHEN (s.stakind3 = 4) THEN s.stavalues3\n            WHEN (s.stakind4 = 4) THEN s.stavalues4\n            WHEN (s.stakind5 = 4) THEN s.stavalues5\n            ELSE NULL::anyarray\n        END AS most_common_elems,\n        CASE\n            WHEN (s.stakind1 = 4) THEN s.stanumbers1\n            WHEN (s.stakind2 = 4) THEN s.stanumbers2\n            WHEN (s.stakind3 = 4) THEN s.stanumbers3\n            WHEN (s.stakind4 = 4) THEN s.stanumbers4\n            WHEN (s.stakind5 = 4) THEN s.stanumbers5\n            ELSE NULL::real[]\n        END AS most_common_elem_freqs,\n        CASE\n            WHEN (s.stakind1 = 5) THEN s.stanumbers1\n            WHEN (s.stakind2 = 5) THEN s.stanumbers2\n            WHEN (s.stakind3 = 5) THEN s.stanumbers3\n            WHEN (s.stakind4 = 5) THEN s.stanumbers4\n            WHEN (s.stakind5 = 5) THEN s.stanumbers5\n            ELSE NULL::real[]\n        END AS elem_count_histogram\n   FROM (((pg_statistic s\n     JOIN pg_class c ON ((c.oid = s.starelid)))\n     JOIN pg_attribute a ON (((c.oid = a.attrelid) AND (a.attnum = s.staattnum))))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE ((NOT a.attisdropped) AND has_column_privilege(c.oid, a.attnum, 'select'::text) AND ((c.relrowsecurity = false) OR (NOT row_security_active(c.oid))));"), ('pg_stats_ext', ' SELECT cn.nspname AS schemaname,\n    c.relname AS tablename,\n    sn.nspname AS statistics_schemaname,\n    s.stxname AS statistics_name,\n    pg_get_userbyid(s.stxowner) AS statistics_owner,\n    ( SELECT array_agg(a.attname ORDER BY a.attnum) AS array_agg\n           FROM (unnest(s.stxkeys) k(k)\n             JOIN pg_attribute a ON (((a.attrelid = s.stxrelid) AND (a.attnum = k.k))))) AS attnames,\n    pg_get_statisticsobjdef_expressions(s.oid) AS exprs,\n    s.stxkind AS kinds,\n    sd.stxdinherit AS inherited,\n    sd.stxdndistinct AS n_distinct,\n    sd.stxddependencies AS dependencies,\n    m.most_common_vals,\n    m.most_common_val_nulls,\n    m.most_common_freqs,\n    m.most_common_base_freqs\n   FROM (((((pg_statistic_ext s\n     JOIN pg_class c ON ((c.oid = s.stxrelid)))\n     JOIN pg_statistic_ext_data sd ON ((s.oid = sd.stxoid)))\n     LEFT JOIN pg_namespace cn ON ((cn.oid = c.relnamespace)))\n     LEFT JOIN pg_namespace sn ON ((sn.oid = s.stxnamespace)))\n     LEFT JOIN LATERAL ( SELECT array_agg(pg_mcv_list_items."values") AS most_common_vals,\n            array_agg(pg_mcv_list_items.nulls) AS most_common_val_nulls,\n            array_agg(pg_mcv_list_items.frequency) AS most_common_freqs,\n            array_agg(pg_mcv_list_items.base_frequency) AS most_common_base_freqs\n           FROM pg_mcv_list_items(sd.stxdmcv) pg_mcv_list_items(index, "values", nulls, frequency, base_frequency)) m ON ((sd.stxdmcv IS NOT NULL)))\n  WHERE ((NOT (EXISTS ( SELECT 1\n           FROM (unnest(s.stxkeys) k(k)\n             JOIN pg_attribute a ON (((a.attrelid = s.stxrelid) AND (a.attnum = k.k))))\n          WHERE (NOT has_column_privilege(c.oid, a.attnum, \'select\'::text))))) AND ((c.relrowsecurity = false) OR (NOT row_security_active(c.oid))));'), ('pg_stats_ext_exprs', ' SELECT cn.nspname AS schemaname,\n    c.relname AS tablename,\n    sn.nspname AS statistics_schemaname,\n    s.stxname AS statistics_name,\n    pg_get_userbyid(s.stxowner) AS statistics_owner,\n    stat.expr,\n    sd.stxdinherit AS inherited,\n    (stat.a).stanullfrac AS null_frac,\n    (stat.a).stawidth AS avg_width,\n    (stat.a).stadistinct AS n_distinct,\n        CASE\n            WHEN ((stat.a).stakind1 = 1) THEN (stat.a).stavalues1\n            WHEN ((stat.a).stakind2 = 1) THEN (stat.a).stavalues2\n            WHEN ((stat.a).stakind3 = 1) THEN (stat.a).stavalues3\n            WHEN ((stat.a).stakind4 = 1) THEN (stat.a).stavalues4\n            WHEN ((stat.a).stakind5 = 1) THEN (stat.a).stavalues5\n            ELSE NULL::anyarray\n        END AS most_common_vals,\n        CASE\n            WHEN ((stat.a).stakind1 = 1) THEN (stat.a).stanumbers1\n            WHEN ((stat.a).stakind2 = 1) THEN (stat.a).stanumbers2\n            WHEN ((stat.a).stakind3 = 1) THEN (stat.a).stanumbers3\n            WHEN ((stat.a).stakind4 = 1) THEN (stat.a).stanumbers4\n            WHEN ((stat.a).stakind5 = 1) THEN (stat.a).stanumbers5\n            ELSE NULL::real[]\n        END AS most_common_freqs,\n        CASE\n            WHEN ((stat.a).stakind1 = 2) THEN (stat.a).stavalues1\n            WHEN ((stat.a).stakind2 = 2) THEN (stat.a).stavalues2\n            WHEN ((stat.a).stakind3 = 2) THEN (stat.a).stavalues3\n            WHEN ((stat.a).stakind4 = 2) THEN (stat.a).stavalues4\n            WHEN ((stat.a).stakind5 = 2) THEN (stat.a).stavalues5\n            ELSE NULL::anyarray\n        END AS histogram_bounds,\n        CASE\n            WHEN ((stat.a).stakind1 = 3) THEN (stat.a).stanumbers1[1]\n            WHEN ((stat.a).stakind2 = 3) THEN (stat.a).stanumbers2[1]\n            WHEN ((stat.a).stakind3 = 3) THEN (stat.a).stanumbers3[1]\n            WHEN ((stat.a).stakind4 = 3) THEN (stat.a).stanumbers4[1]\n            WHEN ((stat.a).stakind5 = 3) THEN (stat.a).stanumbers5[1]\n            ELSE NULL::real\n        END AS correlation,\n        CASE\n            WHEN ((stat.a).stakind1 = 4) THEN (stat.a).stavalues1\n            WHEN ((stat.a).stakind2 = 4) THEN (stat.a).stavalues2\n            WHEN ((stat.a).stakind3 = 4) THEN (stat.a).stavalues3\n            WHEN ((stat.a).stakind4 = 4) THEN (stat.a).stavalues4\n            WHEN ((stat.a).stakind5 = 4) THEN (stat.a).stavalues5\n            ELSE NULL::anyarray\n        END AS most_common_elems,\n        CASE\n            WHEN ((stat.a).stakind1 = 4) THEN (stat.a).stanumbers1\n            WHEN ((stat.a).stakind2 = 4) THEN (stat.a).stanumbers2\n            WHEN ((stat.a).stakind3 = 4) THEN (stat.a).stanumbers3\n            WHEN ((stat.a).stakind4 = 4) THEN (stat.a).stanumbers4\n            WHEN ((stat.a).stakind5 = 4) THEN (stat.a).stanumbers5\n            ELSE NULL::real[]\n        END AS most_common_elem_freqs,\n        CASE\n            WHEN ((stat.a).stakind1 = 5) THEN (stat.a).stanumbers1\n            WHEN ((stat.a).stakind2 = 5) THEN (stat.a).stanumbers2\n            WHEN ((stat.a).stakind3 = 5) THEN (stat.a).stanumbers3\n            WHEN ((stat.a).stakind4 = 5) THEN (stat.a).stanumbers4\n            WHEN ((stat.a).stakind5 = 5) THEN (stat.a).stanumbers5\n            ELSE NULL::real[]\n        END AS elem_count_histogram\n   FROM (((((pg_statistic_ext s\n     JOIN pg_class c ON ((c.oid = s.stxrelid)))\n     LEFT JOIN pg_statistic_ext_data sd ON ((s.oid = sd.stxoid)))\n     LEFT JOIN pg_namespace cn ON ((cn.oid = c.relnamespace)))\n     LEFT JOIN pg_namespace sn ON ((sn.oid = s.stxnamespace)))\n     JOIN LATERAL ( SELECT unnest(pg_get_statisticsobjdef_expressions(s.oid)) AS expr,\n            unnest(sd.stxdexpr) AS a) stat ON ((stat.expr IS NOT NULL)));'), ('pg_tables', ' SELECT n.nspname AS schemaname,\n    c.relname AS tablename,\n    pg_get_userbyid(c.relowner) AS tableowner,\n    t.spcname AS tablespace,\n    c.relhasindex AS hasindexes,\n    c.relhasrules AS hasrules,\n    c.relhastriggers AS hastriggers,\n    c.relrowsecurity AS rowsecurity\n   FROM ((pg_class c\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n     LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace)))\n  WHERE (c.relkind = ANY (ARRAY[\'r\'::"char", \'p\'::"char"]));'), ('pg_timezone_abbrevs', ' SELECT abbrev,\n    utc_offset,\n    is_dst\n   FROM pg_timezone_abbrevs() pg_timezone_abbrevs(abbrev, utc_offset, is_dst);'), ('pg_timezone_names', ' SELECT name,\n    abbrev,\n    utc_offset,\n    is_dst\n   FROM pg_timezone_names() pg_timezone_names(name, abbrev, utc_offset, is_dst);'), ('pg_user', " SELECT usename,\n    usesysid,\n    usecreatedb,\n    usesuper,\n    userepl,\n    usebypassrls,\n    '********'::text AS passwd,\n    valuntil,\n    useconfig\n   FROM pg_shadow;"), ('pg_user_mappings', " SELECT u.oid AS umid,\n    s.oid AS srvid,\n    s.srvname,\n    u.umuser,\n        CASE\n            WHEN (u.umuser = (0)::oid) THEN 'public'::name\n            ELSE a.rolname\n        END AS usename,\n        CASE\n            WHEN (((u.umuser <> (0)::oid) AND (a.rolname = CURRENT_USER) AND (pg_has_role(s.srvowner, 'USAGE'::text) OR has_server_privilege(s.oid, 'USAGE'::text))) OR ((u.umuser = (0)::oid) AND pg_has_role(s.srvowner, 'USAGE'::text)) OR ( SELECT pg_authid.rolsuper\n               FROM pg_authid\n              WHERE (pg_authid.rolname = CURRENT_USER))) THEN u.umoptions\n            ELSE NULL::text[]\n        END AS umoptions\n   FROM ((pg_user_mapping u\n     JOIN pg_foreign_server s ON ((u.umserver = s.oid)))\n     LEFT JOIN pg_authid a ON ((a.oid = u.umuser)));"), ('pg_views', ' SELECT n.nspname AS schemaname,\n    c.relname AS viewname,\n    pg_get_userbyid(c.relowner) AS viewowner,\n    pg_get_viewdef(c.oid) AS definition\n   FROM (pg_class c\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE (c.relkind = \'v\'::"char");')]
+--------------------+
--Query--
SELECT tablename, rulename, definition FROM pg_rules WHERE schemaname = 'pg_catalog' ORDER BY tablename, rulename
--Result--
[('pg_settings', 'pg_settings_n', 'CREATE RULE pg_settings_n AS\n    ON UPDATE TO pg_catalog.pg_settings DO INSTEAD NOTHING;'), ('pg_settings', 'pg_settings_u', 'CREATE RULE pg_settings_u AS\n    ON UPDATE TO pg_catalog.pg_settings\n   WHERE (new.name = old.name) DO  SELECT set_config(old.name, new.setting, false) AS set_config;')]
+--------------------+
--Query--
SELECT * FROM ruletest_tbl2
--Result--
[(10, 10), (1000, 1000)]
+--------------------+
--Query--
select * from id_ordered
--Result--
[(1, 'Test 1'), (2, 'Test 2'), (3, 'Test 3'), (4, 'Test 4'), (5, 'Test 5'), (6, 'Test 6')]
+--------------------+
--Query--
select * from id_ordered
--Result--
[(1, 'Test 1'), (2, 'update 2'), (3, 'Test 3'), (4, 'update 4'), (5, 'update 5'), (6, 'Test 6')]
+--------------------+
--Query--
select * from only t1
--Result--
[]
+--------------------+
--Query--
select * from only t1_1
--Result--
[(6,), (7,), (8,), (9,), (4,)]
+--------------------+
--Query--
select * from only t1_2
--Result--
[(10,), (11,), (12,), (13,), (14,), (15,), (16,), (17,), (18,), (19,)]
+--------------------+
--Query--
select pg_get_viewdef('shoe'::regclass) as unpretty
--Result--
[(' SELECT sh.shoename,\n    sh.sh_avail,\n    sh.slcolor,\n    sh.slminlen,\n    (sh.slminlen * un.un_fact) AS slminlen_cm,\n    sh.slmaxlen,\n    (sh.slmaxlen * un.un_fact) AS slmaxlen_cm,\n    sh.slunit\n   FROM shoe_data sh,\n    unit un\n  WHERE (sh.slunit = un.un_name);',)]
+--------------------+
--Query--
select pg_get_viewdef('shoe'::regclass,true) as pretty
--Result--
[(' SELECT sh.shoename,\n    sh.sh_avail,\n    sh.slcolor,\n    sh.slminlen,\n    sh.slminlen * un.un_fact AS slminlen_cm,\n    sh.slmaxlen,\n    sh.slmaxlen * un.un_fact AS slmaxlen_cm,\n    sh.slunit\n   FROM shoe_data sh,\n    unit un\n  WHERE sh.slunit = un.un_name;',)]
+--------------------+
--Query--
select pg_get_viewdef('shoe'::regclass,0) as prettier
--Result--
[(' SELECT sh.shoename,\n    sh.sh_avail,\n    sh.slcolor,\n    sh.slminlen,\n    sh.slminlen * un.un_fact AS slminlen_cm,\n    sh.slmaxlen,\n    sh.slmaxlen * un.un_fact AS slmaxlen_cm,\n    sh.slunit\n   FROM shoe_data sh,\n    unit un\n  WHERE sh.slunit = un.un_name;',)]
+--------------------+
--Query--
select * from rules_src
--Result--
[(1, 30), (11, 130)]
+--------------------+
--Query--
select * from rules_log
--Result--
[(1, 2, 'old', 1), (1, 3, 'new', 2), (11, 12, 'old', 3), (11, 13, 'new', 4), (1, 3, 'old', 5), (1, 30, 'new', 6), (11, 13, 'old', 7), (11, 130, 'new', 8)]
+--------------------+
--Query--
select * from rules_src
--Result--
[(1, 3), (11, 13), (22, 23), (33, 0)]
+--------------------+
--Query--
select * from rules_log
--Result--
[(1, 2, 'old', 1), (1, 3, 'new', 2), (11, 12, 'old', 3), (11, 13, 'new', 4), (1, 3, 'old', 5), (1, 30, 'new', 6), (11, 13, 'old', 7), (11, 130, 'new', 8), (1, 30, 'old', 9), (1, 3, 'new', 10), (11, 130, 'old', 11), (11, 13, 'new', 12), (None, None, '-', 13), (22, 23, 'new', 14), (None, None, '-', 15), (33, 0, 'new', 16)]
+--------------------+
--Query--
SELECT * FROM rule_t1
--Result--
[(1, 'A', 10), (2, 'B', 20), (11, 'XXX', 110), (12, 'XXX', 120)]
+--------------------+
--Query--
SELECT * FROM rule_v1
--Result--
[(1,)]
+--------------------+
--Query--
SELECT definition FROM pg_rules WHERE tablename = 'hats' ORDER BY rulename
--Result--
[('CREATE RULE hat_nosert AS\n    ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)\n  VALUES (new.hat_name, new.hat_color) ON CONFLICT(hat_name COLLATE "C" bpchar_pattern_ops)\n  WHERE (hat_color = \'green\'::bpchar) DO NOTHING\n  RETURNING hat_data.hat_name,\n    hat_data.hat_color;',)]
+--------------------+
--Query--
SELECT tablename, rulename, definition FROM pg_rules 	WHERE tablename = 'hats'
--Result--
[('hats', 'hat_nosert', 'CREATE RULE hat_nosert AS\n    ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)\n  VALUES (new.hat_name, new.hat_color) ON CONFLICT(hat_name COLLATE "C" bpchar_pattern_ops)\n  WHERE (hat_color = \'green\'::bpchar) DO NOTHING\n  RETURNING hat_data.hat_name,\n    hat_data.hat_color;')]
+--------------------+
--Query--
SELECT definition FROM pg_rules WHERE tablename = 'hats' ORDER BY rulename
--Result--
[('CREATE RULE hat_nosert_all AS\n    ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)\n  VALUES (new.hat_name, new.hat_color) ON CONFLICT DO NOTHING\n  RETURNING hat_data.hat_name,\n    hat_data.hat_color;',)]
+--------------------+
--Query--
SELECT definition FROM pg_rules WHERE tablename = 'hats' ORDER BY rulename
--Result--
[("CREATE RULE hat_upsert AS\n    ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)\n  VALUES (new.hat_name, new.hat_color) ON CONFLICT(hat_name) DO UPDATE SET hat_name = hat_data.hat_name, hat_color = excluded.hat_color\n  WHERE ((excluded.hat_color <> 'forbidden'::bpchar) AND (hat_data.* <> excluded.*))\n  RETURNING hat_data.hat_name,\n    hat_data.hat_color;",)]
+--------------------+
--Query--
SELECT * FROM hat_data WHERE hat_name = 'h8'
--Result--
[('h8        ', 'black     ')]
+--------------------+
--Query--
SELECT * FROM hat_data WHERE hat_name = 'h8'
--Result--
[('h8        ', 'white     ')]
+--------------------+
--Query--
SELECT * FROM hat_data WHERE hat_name = 'h8'
--Result--
[('h8        ', 'white     ')]
+--------------------+
--Query--
SELECT tablename, rulename, definition FROM pg_rules 	WHERE tablename = 'hats'
--Result--
[('hats', 'hat_upsert', "CREATE RULE hat_upsert AS\n    ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)\n  VALUES (new.hat_name, new.hat_color) ON CONFLICT(hat_name) DO UPDATE SET hat_name = hat_data.hat_name, hat_color = excluded.hat_color\n  WHERE ((excluded.hat_color <> 'forbidden'::bpchar) AND (hat_data.* <> excluded.*))\n  RETURNING hat_data.hat_name,\n    hat_data.hat_color;")]
+--------------------+
--Query--
explain (costs off) INSERT INTO hats VALUES ('h8', 'forbidden') RETURNING *
--Result--
[('Insert on hat_data',), ('  Conflict Resolution: UPDATE',), ('  Conflict Arbiter Indexes: hat_data_unique_idx',), ("  Conflict Filter: ((excluded.hat_color <> 'forbidden'::bpchar) AND (hat_data.* <> excluded.*))",), ('  ->  Result',)]
+--------------------+
--Query--
WITH data(hat_name, hat_color) AS MATERIALIZED (     VALUES ('h8', 'green'),         ('h9', 'blue'),         ('h7', 'forbidden') ) INSERT INTO hats     SELECT * FROM data RETURNING *
--Result--
[('h8        ', 'green     '), ('h9        ', 'blue      ')]
+--------------------+
--Query--
EXPLAIN (costs off) WITH data(hat_name, hat_color) AS MATERIALIZED (     VALUES ('h8', 'green'),         ('h9', 'blue'),         ('h7', 'forbidden') ) INSERT INTO hats     SELECT * FROM data RETURNING *
--Result--
[('Insert on hat_data',), ('  Conflict Resolution: UPDATE',), ('  Conflict Arbiter Indexes: hat_data_unique_idx',), ("  Conflict Filter: ((excluded.hat_color <> 'forbidden'::bpchar) AND (hat_data.* <> excluded.*))",), ('  CTE data',), ('    ->  Values Scan on "*VALUES*"',), ('  ->  CTE Scan on data',)]
+--------------------+
--Query--
SELECT * FROM hat_data WHERE hat_name IN ('h8', 'h9', 'h7') ORDER BY hat_name
--Result--
[('h7        ', 'black     '), ('h8        ', 'green     '), ('h9        ', 'blue      ')]
+--------------------+
--Query--
SELECT pg_get_constraintdef(0)
--Result--
[(None,)]
+--------------------+
--Query--
SELECT pg_get_functiondef(0)
--Result--
[(None,)]
+--------------------+
--Query--
SELECT pg_get_indexdef(0)
--Result--
[(None,)]
+--------------------+
--Query--
SELECT pg_get_ruledef(0)
--Result--
[(None,)]
+--------------------+
--Query--
SELECT pg_get_statisticsobjdef(0)
--Result--
[(None,)]
+--------------------+
--Query--
SELECT pg_get_triggerdef(0)
--Result--
[(None,)]
+--------------------+
--Query--
SELECT pg_get_viewdef(0)
--Result--
[(None,)]
+--------------------+
--Query--
SELECT pg_get_function_arguments(0)
--Result--
[(None,)]
+--------------------+
--Query--
SELECT pg_get_function_identity_arguments(0)
--Result--
[(None,)]
+--------------------+
--Query--
SELECT pg_get_function_result(0)
--Result--
[(None,)]
+--------------------+
--Query--
SELECT pg_get_function_arg_default(0, 0)
--Result--
[(None,)]
+--------------------+
--Query--
SELECT pg_get_function_arg_default('pg_class'::regclass, 0)
--Result--
[(None,)]
+--------------------+
--Query--
SELECT pg_get_partkeydef(0)
--Result--
[(None,)]
+--------------------+
--Query--
MERGE INTO rule_merge2 t USING (SELECT 1 AS a) s 	ON t.a = s.a 	WHEN MATCHED AND t.a < 2 THEN 		UPDATE SET b = b || ' updated by merge' 	WHEN MATCHED AND t.a > 2 THEN 		DELETE 	WHEN NOT MATCHED THEN 		INSERT VALUES (s.a, '')
--Result--
[]
+--------------------+
--Query--
SELECT * FROM ruletest1
--Result--
[(2,), (4,), (5,)]
+--------------------+
--Query--
SELECT * FROM ruletest2
--Result--
[(1,), (3,)]
+--------------------+
--Query--
SELECT * FROM ruletest_t1
--Result--
[]
+--------------------+
--Query--
SELECT * FROM ruletest_t2
--Result--
[(1,)]
+--------------------+
