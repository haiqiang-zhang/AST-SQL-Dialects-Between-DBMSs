--Query--
SELECT * FROM xmltest
--Result--
[(1, '<value>one</value>'), (2, '<value>two</value>')]
+--------------------+
--Query--
SELECT pg_input_is_valid('<value>one</value>', 'xml')
--Result--
[(True,)]
+--------------------+
--Query--
SELECT message FROM pg_input_error_info('<value>one</', 'xml')
--Result--
[('invalid XML content',)]
+--------------------+
--Query--
SELECT xmlcomment('test')
--Result--
[('<!--test-->',)]
+--------------------+
--Query--
SELECT xmlconcat(xmlcomment('hello'),                  xmlelement(NAME qux, 'foo'),                  xmlcomment('world'))
--Result--
[('<!--hello--><qux>foo</qux><!--world-->',)]
+--------------------+
--Query--
SELECT xmlelement(name element,                   xmlattributes (1 as one, 'deuce' as two),                   'content')
--Result--
[('<element one="1" two="deuce">content</element>',)]
+--------------------+
--Query--
SELECT xmlparse(content '')
--Result--
[('',)]
+--------------------+
--Query--
SELECT xmlpi(name foo)
--Result--
[('<?foo?>',)]
+--------------------+
--Query--
SELECT xmlroot(xml '<foo/>', version no value, standalone no value)
--Result--
[('<foo/>',)]
+--------------------+
--Query--
SELECT xmlserialize(content data as character varying(20)) FROM xmltest
--Result--
[('<value>one</value>',), ('<value>two</value>',)]
+--------------------+
--Query--
SELECT xmlserialize(DOCUMENT '<foo><bar><val x="y">42</val></bar></foo>' AS text) = xmlserialize(DOCUMENT '<foo><bar><val x="y">42</val></bar></foo>' AS text NO INDENT)
--Result--
[(True,)]
+--------------------+
--Query--
SELECT xmlserialize(CONTENT  '<foo><bar><val x="y">42</val></bar></foo>' AS text) = xmlserialize(CONTENT '<foo><bar><val x="y">42</val></bar></foo>' AS text NO INDENT)
--Result--
[(True,)]
+--------------------+
--Query--
SELECT xml '<foo>bar</foo>' IS DOCUMENT
--Result--
[(True,)]
+--------------------+
--Query--
SELECT xml '<foo>bar</foo><bar>foo</bar>' IS DOCUMENT
--Result--
[(False,)]
+--------------------+
--Query--
SELECT xml '<abc/>' IS NOT DOCUMENT
--Result--
[(False,)]
+--------------------+
--Query--
SELECT xml 'abc' IS NOT DOCUMENT
--Result--
[(True,)]
+--------------------+
--Query--
SELECT xmlagg(data) FROM xmltest
--Result--
[('<value>one</value><value>two</value>',)]
+--------------------+
--Query--
PREPARE foo (xml) AS SELECT xmlconcat('<foo/>', $1)
--Result--
[]
+--------------------+
--Query--
EXECUTE foo ('<bar/>')
--Result--
[('<foo/><bar/>',)]
+--------------------+
--Query--
SELECT table_name, view_definition FROM information_schema.views   WHERE table_name LIKE 'xmlview%' ORDER BY 1
--Result--
[('xmlview1', " SELECT xmlcomment('test'::text) AS xmlcomment;"), ('xmlview2', ' SELECT XMLCONCAT(\'hello\'::xml, \'you\'::xml) AS "xmlconcat";'), ('xmlview3', ' SELECT XMLELEMENT(NAME element, XMLATTRIBUTES(1 AS ":one:", \'deuce\' AS two), \'content&\') AS "xmlelement";'), ('xmlview5', ' SELECT XMLPARSE(CONTENT \'<abc>x</abc>\'::text STRIP WHITESPACE) AS "xmlparse";'), ('xmlview6', ' SELECT XMLPI(NAME foo, \'bar\'::text) AS "xmlpi";'), ('xmlview7', ' SELECT XMLROOT(\'<foo/>\'::xml, VERSION NO VALUE, STANDALONE YES) AS "xmlroot";'), ('xmlview8', ' SELECT (XMLSERIALIZE(CONTENT \'good\'::xml AS character(10)))::character(10) AS "xmlserialize";'), ('xmlview9', ' SELECT XMLSERIALIZE(CONTENT \'good\'::xml AS text) AS "xmlserialize";')]
+--------------------+
--Query--
SELECT xpath('/value', data) FROM xmltest
--Result--
[('{<value>one</value>}',), ('{<value>two</value>}',)]
+--------------------+
--Query--
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY REF '<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>')
--Result--
[(False,)]
+--------------------+
--Query--
SELECT xpath_exists('//town[text() = ''Toronto'']','<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>'::xml)
--Result--
[(False,)]
+--------------------+
--Query--
SELECT COUNT(id) FROM xmltest WHERE xmlexists('/menu/beer' PASSING data)
--Result--
[(0,)]
+--------------------+
--Query--
SELECT xml_is_well_formed_document('<foo>bar</foo>')
--Result--
[(True,)]
+--------------------+
--Query--
SELECT xml_is_well_formed_content('<foo>bar</foo>')
--Result--
[(True,)]
+--------------------+
--Query--
SELECT xml_is_well_formed('abc')
--Result--
[(False,)]
+--------------------+
--Query--
SELECT  xmltable.*    FROM (SELECT data FROM xmldata) x,         LATERAL XMLTABLE('/ROWS/ROW'                          PASSING data                          COLUMNS id int PATH '@id',                                   _id FOR ORDINALITY,                                   country_name text PATH 'COUNTRY_NAME/text()' NOT NULL,                                   country_id text PATH 'COUNTRY_ID',                                   region_id int PATH 'REGION_ID',                                   size float PATH 'SIZE',                                   unit text PATH 'SIZE/@unit',                                   premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified')
--Result--
[(1, 1, 'Australia', 'AU', 3, None, None, 'not specified'), (2, 2, 'China', 'CN', 3, None, None, 'not specified'), (3, 3, 'HongKong', 'HK', 3, None, None, 'not specified'), (4, 4, 'India', 'IN', 3, None, None, 'not specified'), (5, 5, 'Japan', 'JP', 3, None, None, 'Sinzo Abe'), (6, 6, 'Singapore', 'SG', 3, 791.0, 'km', 'not specified')]
+--------------------+
--Query--
SELECT * FROM xmltableview1
--Result--
[(1, 1, 'Australia', 'AU', 3, None, None, 'not specified'), (2, 2, 'China', 'CN', 3, None, None, 'not specified'), (3, 3, 'HongKong', 'HK', 3, None, None, 'not specified'), (4, 4, 'India', 'IN', 3, None, None, 'not specified'), (5, 5, 'Japan', 'JP', 3, None, None, 'Sinzo Abe'), (6, 6, 'Singapore', 'SG', 3, 791.0, 'km', 'not specified')]
+--------------------+
--Query--
EXPLAIN (COSTS OFF) SELECT * FROM xmltableview1
--Result--
[('Nested Loop',), ('  ->  Seq Scan on xmldata',), ('  ->  Table Function Scan on "xmltable"',)]
+--------------------+
--Query--
EXPLAIN (COSTS OFF, VERBOSE) SELECT * FROM xmltableview1
--Result--
[('Nested Loop',), ('  Output: "xmltable".id, "xmltable"._id, "xmltable".country_name, "xmltable".country_id, "xmltable".region_id, "xmltable".size, "xmltable".unit, "xmltable".premier_name',), ('  ->  Seq Scan on public.xmldata',), ('        Output: xmldata.data',), ('  ->  Table Function Scan on "xmltable"',), ('        Output: "xmltable".id, "xmltable"._id, "xmltable".country_name, "xmltable".country_id, "xmltable".region_id, "xmltable".size, "xmltable".unit, "xmltable".premier_name',), ("        Table Function Call: XMLTABLE(('/ROWS/ROW'::text) PASSING (xmldata.data) COLUMNS id integer PATH ('@id'::text), _id FOR ORDINALITY, country_name text PATH ('COUNTRY_NAME/text()'::text) NOT NULL, country_id text PATH ('COUNTRY_ID'::text), region_id integer PATH ('REGION_ID'::text), size double precision PATH ('SIZE'::text), unit text PATH ('SIZE/@unit'::text), premier_name text DEFAULT ('not specified'::text) PATH ('PREMIER_NAME'::text))",)]
+--------------------+
--Query--
SELECT * FROM xmltableview2
--Result--
[(10,)]
+--------------------+
--Query--
PREPARE pp AS SELECT  xmltable.*    FROM (SELECT data FROM xmldata) x,         LATERAL XMLTABLE('/ROWS/ROW'                          PASSING data                          COLUMNS id int PATH '@id',                                   _id FOR ORDINALITY,                                   country_name text PATH 'COUNTRY_NAME' NOT NULL,                                   country_id text PATH 'COUNTRY_ID',                                   region_id int PATH 'REGION_ID',                                   size float PATH 'SIZE',                                   unit text PATH 'SIZE/@unit',                                   premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified')
--Result--
[]
+--------------------+
--Query--
EXECUTE pp
--Result--
[(1, 1, 'Australia', 'AU', 3, None, None, 'not specified'), (2, 2, 'China', 'CN', 3, None, None, 'not specified'), (3, 3, 'HongKong', 'HK', 3, None, None, 'not specified'), (4, 4, 'India', 'IN', 3, None, None, 'not specified'), (5, 5, 'Japan', 'JP', 3, None, None, 'Sinzo Abe'), (6, 6, 'Singapore', 'SG', 3, 791.0, 'km', 'not specified')]
+--------------------+
--Query--
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS "COUNTRY_NAME" text, "REGION_ID" int)
--Result--
[('India', 3), ('Japan', 3)]
+--------------------+
--Query--
EXPLAIN (VERBOSE, COSTS OFF) SELECT  xmltable.*    FROM (SELECT data FROM xmldata) x,         LATERAL XMLTABLE('/ROWS/ROW'                          PASSING data                          COLUMNS id int PATH '@id',                                   _id FOR ORDINALITY,                                   country_name text PATH 'COUNTRY_NAME' NOT NULL,                                   country_id text PATH 'COUNTRY_ID',                                   region_id int PATH 'REGION_ID',                                   size float PATH 'SIZE',                                   unit text PATH 'SIZE/@unit',                                   premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified')
--Result--
[('Nested Loop',), ('  Output: "xmltable".id, "xmltable"._id, "xmltable".country_name, "xmltable".country_id, "xmltable".region_id, "xmltable".size, "xmltable".unit, "xmltable".premier_name',), ('  ->  Seq Scan on public.xmldata',), ('        Output: xmldata.data',), ('  ->  Table Function Scan on "xmltable"',), ('        Output: "xmltable".id, "xmltable"._id, "xmltable".country_name, "xmltable".country_id, "xmltable".region_id, "xmltable".size, "xmltable".unit, "xmltable".premier_name',), ("        Table Function Call: XMLTABLE(('/ROWS/ROW'::text) PASSING (xmldata.data) COLUMNS id integer PATH ('@id'::text), _id FOR ORDINALITY, country_name text PATH ('COUNTRY_NAME'::text) NOT NULL, country_id text PATH ('COUNTRY_ID'::text), region_id integer PATH ('REGION_ID'::text), size double precision PATH ('SIZE'::text), unit text PATH ('SIZE/@unit'::text), premier_name text DEFAULT ('not specified'::text) PATH ('PREMIER_NAME'::text))",)]
+--------------------+
--Query--
EXPLAIN (VERBOSE, COSTS OFF) SELECT f.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS "COUNTRY_NAME" text, "REGION_ID" int) AS f WHERE "COUNTRY_NAME" = 'Japan'
--Result--
[('Nested Loop',), ('  Output: f."COUNTRY_NAME", f."REGION_ID"',), ('  ->  Seq Scan on public.xmldata',), ('        Output: xmldata.data',), ('  ->  Table Function Scan on "xmltable" f',), ('        Output: f."COUNTRY_NAME", f."REGION_ID"',), ('        Table Function Call: XMLTABLE((\'/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]\'::text) PASSING (xmldata.data) COLUMNS "COUNTRY_NAME" text, "REGION_ID" integer)',), ('        Filter: (f."COUNTRY_NAME" = \'Japan\'::text)',)]
+--------------------+
--Query--
EXPLAIN (VERBOSE, FORMAT JSON, COSTS OFF) SELECT f.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS "COUNTRY_NAME" text, "REGION_ID" int) AS f WHERE "COUNTRY_NAME" = 'Japan'
--Result--
[([{'Plan': {'Node Type': 'Nested Loop', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Output': ['f."COUNTRY_NAME"', 'f."REGION_ID"'], 'Inner Unique': False, 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'xmldata', 'Schema': 'public', 'Alias': 'xmldata', 'Output': ['xmldata.data']}, {'Node Type': 'Table Function Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Table Function Name': 'xmltable', 'Alias': 'f', 'Output': ['f."COUNTRY_NAME"', 'f."REGION_ID"'], 'Table Function Call': 'XMLTABLE((\'/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]\'::text) PASSING (xmldata.data) COLUMNS "COUNTRY_NAME" text, "REGION_ID" integer)', 'Filter': '(f."COUNTRY_NAME" = \'Japan\'::text)'}]}}],)]
+--------------------+
--Query--
WITH    x AS (SELECT proname, proowner, procost::numeric, pronargs,                 array_to_string(proargnames,',') as proargnames,                 case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes            FROM pg_proc WHERE proname = 'f_leak'),    y AS (SELECT xmlelement(name proc,                            xmlforest(proname, proowner,                                      procost, pronargs,                                      proargnames, proargtypes)) as proc            FROM x),    z AS (SELECT xmltable.*            FROM y,                 LATERAL xmltable('/proc' PASSING proc                                  COLUMNS proname name,                                          proowner oid,                                          procost float,                                          pronargs int,                                          proargnames text,                                          proargtypes text))    SELECT * FROM z    EXCEPT SELECT * FROM x
--Result--
[]
+--------------------+
--Query--
WITH    x AS (SELECT proname, proowner, procost::numeric, pronargs,                 array_to_string(proargnames,',') as proargnames,                 case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes            FROM pg_proc),    y AS (SELECT xmlelement(name data,                            xmlagg(xmlelement(name proc,                                              xmlforest(proname, proowner, procost,                                                        pronargs, proargnames, proargtypes)))) as doc            FROM x),    z AS (SELECT xmltable.*            FROM y,                 LATERAL xmltable('/data/proc' PASSING doc                                  COLUMNS proname name,                                          proowner oid,                                          procost float,                                          pronargs int,                                          proargnames text,                                          proargtypes text))    SELECT * FROM z    EXCEPT SELECT * FROM x
--Result--
[]
+--------------------+
