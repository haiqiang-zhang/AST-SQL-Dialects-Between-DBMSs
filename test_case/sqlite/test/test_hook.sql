SELECT * FROM t2;
INSERT INTO t2 VALUES(6,7);
SELECT * FROM t2;
SELECT * FROM t2;
INSERT INTO t2 VALUES(7,8);
CREATE TABLE t1(a INTEGER PRIMARY KEY, b);
CREATE TABLE t1w(a INT PRIMARY KEY, b) WITHOUT ROWID;
INSERT INTO t1 VALUES(1, 'one');
INSERT INTO t1 VALUES(2, 'two');
INSERT INTO t1 VALUES(3, 'three');
INSERT INTO t1w SELECT * FROM t1;
INSERT INTO t1 VALUES(4, 'four');
DELETE FROM t1 WHERE b = 'two';
UPDATE t1 SET b = '' WHERE a = 1 OR a = 3;
DELETE FROM t1 WHERE 1;
-- Avoid the truncate optimization (for now);
INSERT INTO t1w VALUES(4, 'four');
DELETE FROM t1w WHERE b = 'two';
UPDATE t1w SET b = '' WHERE a = 1 OR a = 3;
DELETE FROM t1w WHERE 1;
-- Avoid the truncate optimization (for now);
DROP TABLE t2;
CREATE TABLE t2(c INTEGER PRIMARY KEY, d);
INSERT INTO t1 VALUES(1, 'one');
INSERT INTO t1 VALUES(2, 'two');
ATTACH 'test2.db' AS aux;
CREATE TABLE aux.t3(a INTEGER PRIMARY KEY, b);
INSERT INTO aux.t3 SELECT * FROM t1;
UPDATE t3 SET b = 'two or so' WHERE a = 2;
DELETE FROM t3 WHERE 1;
-- Avoid the truncate optimization (for now);
CREATE INDEX t1_i ON t1(b);
INSERT INTO t1 VALUES(3, 'three');
UPDATE t1 SET b = '';
DELETE FROM t1 WHERE a > 1;
SELECT * FROM t1 UNION SELECT * FROM t3;
SELECT * FROM t1 UNION ALL SELECT * FROM t3;
SELECT * FROM t1 INTERSECT SELECT * FROM t3;
SELECT * FROM t1 EXCEPT SELECT * FROM t3;
SELECT * FROM t1 ORDER BY b;
SELECT * FROM t1 GROUP BY b;
CREATE TABLE t4(a UNIQUE, b);
INSERT INTO t4 VALUES(1, 'a');
INSERT INTO t4 VALUES(2, 'b');
REPLACE INTO t4 VALUES(1, 'c');
SELECT * FROM t4 ORDER BY a;
PRAGMA recursive_triggers = on;
REPLACE INTO t4 VALUES(1, 'd');
SELECT * FROM t4 ORDER BY a;
BEGIN;
DROP TABLE t1;
CREATE TABLE t1(a PRIMARY KEY, b);
INSERT INTO t1 VALUES('one', 'I');
SELECT count(*) FROM t1;
BEGIN;
INSERT INTO t1 VALUES('two', 'II');
SELECT * FROM t1;
